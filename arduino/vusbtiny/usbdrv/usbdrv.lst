GAS LISTING /tmp/ccBGRCFe.s 			page 1


   1               		.file	"usbdrv.c"
   2               	__SP_L__ = 0x3d
   3               	__SREG__ = 0x3f
   4               	__tmp_reg__ = 0
   5               	__zero_reg__ = 1
   6               		.stabs	"/home/mark/workspace_c/vusbtiny/",100,0,2,.Ltext0
   7               		.stabs	"usbdrv/usbdrv.c",100,0,2,.Ltext0
   8               		.text
   9               	.Ltext0:
  10               		.stabs	"gcc2_compiled.",60,0,0,0
  11               		.stabs	"int:t(0,1)=r(0,1);-32768;32767;",128,0,0,0
  12               		.stabs	"char:t(0,2)=@s8;r(0,2);0;255;",128,0,0,0
  13               		.stabs	"long int:t(0,3)=@s32;r(0,3);020000000000;017777777777;",128,0,0,0
  14               		.stabs	"unsigned int:t(0,4)=r(0,4);0;0177777;",128,0,0,0
  15               		.stabs	"long unsigned int:t(0,5)=@s32;r(0,5);0;037777777777;",128,0,0,0
  16               		.stabs	"long long int:t(0,6)=@s64;r(0,6);01000000000000000000000;0777777777777777777777;",128,0,0,
  17               		.stabs	"long long unsigned int:t(0,7)=@s64;r(0,7);0;01777777777777777777777;",128,0,0,0
  18               		.stabs	"short int:t(0,8)=r(0,8);-32768;32767;",128,0,0,0
  19               		.stabs	"short unsigned int:t(0,9)=r(0,9);0;0177777;",128,0,0,0
  20               		.stabs	"signed char:t(0,10)=@s8;r(0,10);-128;127;",128,0,0,0
  21               		.stabs	"unsigned char:t(0,11)=@s8;r(0,11);0;255;",128,0,0,0
  22               		.stabs	"float:t(0,12)=r(0,1);4;0;",128,0,0,0
  23               		.stabs	"double:t(0,13)=r(0,1);4;0;",128,0,0,0
  24               		.stabs	"long double:t(0,14)=r(0,1);4;0;",128,0,0,0
  25               		.stabs	"short _Fract:t(0,15)=r(0,1);1;0;",128,0,0,0
  26               		.stabs	"_Fract:t(0,16)=r(0,1);2;0;",128,0,0,0
  27               		.stabs	"long _Fract:t(0,17)=r(0,1);4;0;",128,0,0,0
  28               		.stabs	"long long _Fract:t(0,18)=r(0,1);8;0;",128,0,0,0
  29               		.stabs	"unsigned short _Fract:t(0,19)=r(0,1);1;0;",128,0,0,0
  30               		.stabs	"unsigned _Fract:t(0,20)=r(0,1);2;0;",128,0,0,0
  31               		.stabs	"unsigned long _Fract:t(0,21)=r(0,1);4;0;",128,0,0,0
  32               		.stabs	"unsigned long long _Fract:t(0,22)=r(0,1);8;0;",128,0,0,0
  33               		.stabs	"_Sat short _Fract:t(0,23)=r(0,1);1;0;",128,0,0,0
  34               		.stabs	"_Sat _Fract:t(0,24)=r(0,1);2;0;",128,0,0,0
  35               		.stabs	"_Sat long _Fract:t(0,25)=r(0,1);4;0;",128,0,0,0
  36               		.stabs	"_Sat long long _Fract:t(0,26)=r(0,1);8;0;",128,0,0,0
  37               		.stabs	"_Sat unsigned short _Fract:t(0,27)=r(0,1);1;0;",128,0,0,0
  38               		.stabs	"_Sat unsigned _Fract:t(0,28)=r(0,1);2;0;",128,0,0,0
  39               		.stabs	"_Sat unsigned long _Fract:t(0,29)=r(0,1);4;0;",128,0,0,0
  40               		.stabs	"_Sat unsigned long long _Fract:t(0,30)=r(0,1);8;0;",128,0,0,0
  41               		.stabs	"short _Accum:t(0,31)=r(0,1);2;0;",128,0,0,0
  42               		.stabs	"_Accum:t(0,32)=r(0,1);4;0;",128,0,0,0
  43               		.stabs	"long _Accum:t(0,33)=r(0,1);8;0;",128,0,0,0
  44               		.stabs	"long long _Accum:t(0,34)=r(0,1);8;0;",128,0,0,0
  45               		.stabs	"unsigned short _Accum:t(0,35)=r(0,1);2;0;",128,0,0,0
  46               		.stabs	"unsigned _Accum:t(0,36)=r(0,1);4;0;",128,0,0,0
  47               		.stabs	"unsigned long _Accum:t(0,37)=r(0,1);8;0;",128,0,0,0
  48               		.stabs	"unsigned long long _Accum:t(0,38)=r(0,1);8;0;",128,0,0,0
  49               		.stabs	"_Sat short _Accum:t(0,39)=r(0,1);2;0;",128,0,0,0
  50               		.stabs	"_Sat _Accum:t(0,40)=r(0,1);4;0;",128,0,0,0
  51               		.stabs	"_Sat long _Accum:t(0,41)=r(0,1);8;0;",128,0,0,0
  52               		.stabs	"_Sat long long _Accum:t(0,42)=r(0,1);8;0;",128,0,0,0
  53               		.stabs	"_Sat unsigned short _Accum:t(0,43)=r(0,1);2;0;",128,0,0,0
  54               		.stabs	"_Sat unsigned _Accum:t(0,44)=r(0,1);4;0;",128,0,0,0
  55               		.stabs	"_Sat unsigned long _Accum:t(0,45)=r(0,1);8;0;",128,0,0,0
  56               		.stabs	"_Sat unsigned long long _Accum:t(0,46)=r(0,1);8;0;",128,0,0,0
  57               		.stabs	"void:t(0,47)=(0,47)",128,0,0,0
GAS LISTING /tmp/ccBGRCFe.s 			page 2


  58               		.stabs	"usbdrv/usbportability.h",130,0,0,0
  59               		.stabs	"/usr/avr/include/avr/io.h",130,0,0,0
  60               		.stabs	"/usr/avr/include/avr/sfr_defs.h",130,0,0,0
  61               		.stabs	"/usr/avr/include/inttypes.h",130,0,0,0
  62               		.stabs	"/usr/lib/gcc/avr/4.8.0/include/stdint.h",130,0,0,0
  63               		.stabs	"/usr/avr/include/stdint.h",130,0,0,0
  64               		.stabs	"int8_t:t(6,1)=(0,10)",128,0,121,0
  65               		.stabs	"uint8_t:t(6,2)=(0,11)",128,0,122,0
  66               		.stabs	"int16_t:t(6,3)=(0,1)",128,0,123,0
  67               		.stabs	"uint16_t:t(6,4)=(0,4)",128,0,124,0
  68               		.stabs	"int32_t:t(6,5)=(0,3)",128,0,125,0
  69               		.stabs	"uint32_t:t(6,6)=(0,5)",128,0,126,0
  70               		.stabs	"int64_t:t(6,7)=(0,6)",128,0,128,0
  71               		.stabs	"uint64_t:t(6,8)=(0,7)",128,0,129,0
  72               		.stabs	"intptr_t:t(6,9)=(6,3)",128,0,142,0
  73               		.stabs	"uintptr_t:t(6,10)=(6,4)",128,0,147,0
  74               		.stabs	"int_least8_t:t(6,11)=(6,1)",128,0,159,0
  75               		.stabs	"uint_least8_t:t(6,12)=(6,2)",128,0,164,0
  76               		.stabs	"int_least16_t:t(6,13)=(6,3)",128,0,169,0
  77               		.stabs	"uint_least16_t:t(6,14)=(6,4)",128,0,174,0
  78               		.stabs	"int_least32_t:t(6,15)=(6,5)",128,0,179,0
  79               		.stabs	"uint_least32_t:t(6,16)=(6,6)",128,0,184,0
  80               		.stabs	"int_least64_t:t(6,17)=(6,7)",128,0,192,0
  81               		.stabs	"uint_least64_t:t(6,18)=(6,8)",128,0,199,0
  82               		.stabs	"int_fast8_t:t(6,19)=(6,1)",128,0,213,0
  83               		.stabs	"uint_fast8_t:t(6,20)=(6,2)",128,0,218,0
  84               		.stabs	"int_fast16_t:t(6,21)=(6,3)",128,0,223,0
  85               		.stabs	"uint_fast16_t:t(6,22)=(6,4)",128,0,228,0
  86               		.stabs	"int_fast32_t:t(6,23)=(6,5)",128,0,233,0
  87               		.stabs	"uint_fast32_t:t(6,24)=(6,6)",128,0,238,0
  88               		.stabs	"int_fast64_t:t(6,25)=(6,7)",128,0,246,0
  89               		.stabs	"uint_fast64_t:t(6,26)=(6,8)",128,0,253,0
  90               		.stabs	"intmax_t:t(6,27)=(6,7)",128,0,273,0
  91               		.stabs	"uintmax_t:t(6,28)=(6,8)",128,0,278,0
  92               		.stabn	162,0,0,0
  93               		.stabn	162,0,0,0
  94               		.stabs	"int_farptr_t:t(4,1)=(6,5)",128,0,77,0
  95               		.stabs	"uint_farptr_t:t(4,2)=(6,6)",128,0,81,0
  96               		.stabn	162,0,0,0
  97               		.stabn	162,0,0,0
  98               		.stabs	"/usr/avr/include/avr/fuse.h",130,0,0,0
  99               		.stabs	"__fuse_t:t(7,1)=(7,2)=s3low:(0,11),0,8;high:(0,11),8,8;extended:(0,11),16,8;;",128,0,244,0
 100               		.stabn	162,0,0,0
 101               		.stabn	162,0,0,0
 102               		.stabs	"/usr/avr/include/avr/pgmspace.h",130,0,0,0
 103               		.stabs	"/usr/lib/gcc/avr/4.8.0/include/stddef.h",130,0,0,0
 104               		.stabs	"size_t:t(9,1)=(0,4)",128,0,212,0
 105               		.stabn	162,0,0,0
 106               		.stabn	162,0,0,0
 107               		.stabn	162,0,0,0
 108               		.stabs	"usbdrv/usbdrv.h",130,0,0,0
 109               		.stabs	"usbTxStatus:T(10,1)=s12len:(10,2)=B(0,11),0,8;buffer:(10,3)=ar(10,4)=r(10,4);0;0177777;;0;
 110               		.stabs	"usbTxStatus_t:t(10,5)=(10,1)",128,0,650,0
 111               		.stabs	"usbWord:T(10,6)=u2word:(0,4),0,16;bytes:(10,7)=ar(10,4);0;1;(0,11),0,16;;",128,0,0,0
 112               		.stabs	"usbWord_t:t(10,8)=(10,6)",128,0,662,0
 113               		.stabs	"usbRequest:T(10,9)=s8bmRequestType:(0,11),0,8;bRequest:(0,11),8,8;wValue:(10,8),16,16;wInd
 114               		.stabs	"usbRequest_t:t(10,10)=(10,9)",128,0,670,0
GAS LISTING /tmp/ccBGRCFe.s 			page 3


 115               		.stabn	162,0,0,0
 116               		.stabs	"usbSetInterrupt:F(0,47)",36,0,245,usbSetInterrupt
 117               		.stabs	"len:P(0,11)",64,0,245,28
 118               	.global	usbSetInterrupt
 119               		.type	usbSetInterrupt, @function
 120               	usbSetInterrupt:
 121               		.stabd	46,0,0
   1:usbdrv/usbdrv.c **** /* Name: usbdrv.c
   2:usbdrv/usbdrv.c ****  * Project: V-USB, virtual USB port for Atmel's(r) AVR(r) microcontrollers
   3:usbdrv/usbdrv.c ****  * Author: Christian Starkjohann
   4:usbdrv/usbdrv.c ****  * Creation Date: 2004-12-29
   5:usbdrv/usbdrv.c ****  * Tabsize: 4
   6:usbdrv/usbdrv.c ****  * Copyright: (c) 2005 by OBJECTIVE DEVELOPMENT Software GmbH
   7:usbdrv/usbdrv.c ****  * License: GNU GPL v2 (see License.txt), GNU GPL v3 or proprietary (CommercialLicense.txt)
   8:usbdrv/usbdrv.c ****  * This Revision: $Id: usbdrv.c 763 2009-08-22 10:27:24Z cs $
   9:usbdrv/usbdrv.c ****  */
  10:usbdrv/usbdrv.c **** 
  11:usbdrv/usbdrv.c **** #include "usbportability.h"
  12:usbdrv/usbdrv.c **** #include "usbdrv.h"
  13:usbdrv/usbdrv.c **** #include "oddebug.h"
  14:usbdrv/usbdrv.c **** 
  15:usbdrv/usbdrv.c **** /*
  16:usbdrv/usbdrv.c **** General Description:
  17:usbdrv/usbdrv.c **** This module implements the C-part of the USB driver. See usbdrv.h for a
  18:usbdrv/usbdrv.c **** documentation of the entire driver.
  19:usbdrv/usbdrv.c **** */
  20:usbdrv/usbdrv.c **** 
  21:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
  22:usbdrv/usbdrv.c **** 
  23:usbdrv/usbdrv.c **** /* raw USB registers / interface to assembler code: */
  24:usbdrv/usbdrv.c **** uchar usbRxBuf[2*USB_BUFSIZE];  /* raw RX buffer: PID, 8 bytes data, 2 bytes CRC */
  25:usbdrv/usbdrv.c **** uchar       usbInputBufOffset;  /* offset in usbRxBuf used for low level receiving */
  26:usbdrv/usbdrv.c **** uchar       usbDeviceAddr;      /* assigned during enumeration, defaults to 0 */
  27:usbdrv/usbdrv.c **** uchar       usbNewDeviceAddr;   /* device ID which should be set after status phase */
  28:usbdrv/usbdrv.c **** uchar       usbConfiguration;   /* currently selected configuration. Administered by driver, but no
  29:usbdrv/usbdrv.c **** volatile schar usbRxLen;        /* = 0; number of bytes in usbRxBuf; 0 means free, -1 for flow cont
  30:usbdrv/usbdrv.c **** uchar       usbCurrentTok;      /* last token received or endpoint number for last OUT token if != 
  31:usbdrv/usbdrv.c **** uchar       usbRxToken;         /* token for data we received; or endpont number for last OUT */
  32:usbdrv/usbdrv.c **** volatile uchar usbTxLen = USBPID_NAK;   /* number of bytes to transmit with next IN token or handsh
  33:usbdrv/usbdrv.c **** uchar       usbTxBuf[USB_BUFSIZE];/* data to transmit with next IN, free if usbTxLen contains hands
  34:usbdrv/usbdrv.c **** #if USB_COUNT_SOF
  35:usbdrv/usbdrv.c **** volatile uchar  usbSofCount;    /* incremented by assembler module every SOF */
  36:usbdrv/usbdrv.c **** #endif
  37:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
  38:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus1;
  39:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
  40:usbdrv/usbdrv.c **** usbTxStatus_t  usbTxStatus3;
  41:usbdrv/usbdrv.c **** #   endif
  42:usbdrv/usbdrv.c **** #endif
  43:usbdrv/usbdrv.c **** #if USB_CFG_CHECK_DATA_TOGGLING
  44:usbdrv/usbdrv.c **** uchar       usbCurrentDataToken;/* when we check data toggling to ignore duplicate packets */
  45:usbdrv/usbdrv.c **** #endif
  46:usbdrv/usbdrv.c **** 
  47:usbdrv/usbdrv.c **** /* USB status registers / not shared with asm code */
  48:usbdrv/usbdrv.c **** uchar               *usbMsgPtr;     /* data to transmit next -- ROM or RAM address */
  49:usbdrv/usbdrv.c **** static usbMsgLen_t  usbMsgLen = USB_NO_MSG; /* remaining number of bytes */
  50:usbdrv/usbdrv.c **** static uchar        usbMsgFlags;    /* flag values see below */
GAS LISTING /tmp/ccBGRCFe.s 			page 4


  51:usbdrv/usbdrv.c **** 
  52:usbdrv/usbdrv.c **** #define USB_FLG_MSGPTR_IS_ROM   (1<<6)
  53:usbdrv/usbdrv.c **** #define USB_FLG_USE_USER_RW     (1<<7)
  54:usbdrv/usbdrv.c **** 
  55:usbdrv/usbdrv.c **** /*
  56:usbdrv/usbdrv.c **** optimizing hints:
  57:usbdrv/usbdrv.c **** - do not post/pre inc/dec integer values in operations
  58:usbdrv/usbdrv.c **** - assign value of USB_READ_FLASH() to register variables and don't use side effects in arg
  59:usbdrv/usbdrv.c **** - use narrow scope for variables which should be in X/Y/Z register
  60:usbdrv/usbdrv.c **** - assign char sized expressions to variables to force 8 bit arithmetics
  61:usbdrv/usbdrv.c **** */
  62:usbdrv/usbdrv.c **** 
  63:usbdrv/usbdrv.c **** /* -------------------------- String Descriptors --------------------------- */
  64:usbdrv/usbdrv.c **** 
  65:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS == 0
  66:usbdrv/usbdrv.c **** 
  67:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_0 == 0
  68:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_0
  69:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_0    sizeof(usbDescriptorString0)
  70:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorString0[] = { /* language descriptor */
  71:usbdrv/usbdrv.c ****     4,          /* sizeof(usbDescriptorString0): length of descriptor in bytes */
  72:usbdrv/usbdrv.c ****     3,          /* descriptor type */
  73:usbdrv/usbdrv.c ****     0x09, 0x04, /* language index (0x0409 = US-English) */
  74:usbdrv/usbdrv.c **** };
  75:usbdrv/usbdrv.c **** #endif
  76:usbdrv/usbdrv.c **** 
  77:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_VENDOR == 0 && USB_CFG_VENDOR_NAME_LEN
  78:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_VENDOR
  79:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_VENDOR   sizeof(usbDescriptorStringVendor)
  80:usbdrv/usbdrv.c **** PROGMEM const int  usbDescriptorStringVendor[] = {
  81:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_VENDOR_NAME_LEN),
  82:usbdrv/usbdrv.c ****     USB_CFG_VENDOR_NAME
  83:usbdrv/usbdrv.c **** };
  84:usbdrv/usbdrv.c **** #endif
  85:usbdrv/usbdrv.c **** 
  86:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_PRODUCT == 0 && USB_CFG_DEVICE_NAME_LEN
  87:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_PRODUCT
  88:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_PRODUCT   sizeof(usbDescriptorStringDevice)
  89:usbdrv/usbdrv.c **** PROGMEM const int  usbDescriptorStringDevice[] = {
  90:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_DEVICE_NAME_LEN),
  91:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_NAME
  92:usbdrv/usbdrv.c **** };
  93:usbdrv/usbdrv.c **** #endif
  94:usbdrv/usbdrv.c **** 
  95:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER == 0 && USB_CFG_SERIAL_NUMBER_LEN
  96:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER
  97:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER    sizeof(usbDescriptorStringSerialNumber)
  98:usbdrv/usbdrv.c **** PROGMEM const int usbDescriptorStringSerialNumber[] = {
  99:usbdrv/usbdrv.c ****     USB_STRING_DESCRIPTOR_HEADER(USB_CFG_SERIAL_NUMBER_LEN),
 100:usbdrv/usbdrv.c ****     USB_CFG_SERIAL_NUMBER
 101:usbdrv/usbdrv.c **** };
 102:usbdrv/usbdrv.c **** #endif
 103:usbdrv/usbdrv.c **** 
 104:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS == 0 */
 105:usbdrv/usbdrv.c **** 
 106:usbdrv/usbdrv.c **** /* --------------------------- Device Descriptor --------------------------- */
 107:usbdrv/usbdrv.c **** 
GAS LISTING /tmp/ccBGRCFe.s 			page 5


 108:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_DEVICE == 0
 109:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_DEVICE
 110:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_DEVICE  sizeof(usbDescriptorDevice)
 111:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorDevice[] = {    /* USB device descriptor */
 112:usbdrv/usbdrv.c ****     18,         /* sizeof(usbDescriptorDevice): length of descriptor in bytes */
 113:usbdrv/usbdrv.c ****     USBDESCR_DEVICE,        /* descriptor type */
 114:usbdrv/usbdrv.c ****     0x10, 0x01,             /* USB version supported */
 115:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_CLASS,
 116:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_SUBCLASS,
 117:usbdrv/usbdrv.c ****     0,                      /* protocol */
 118:usbdrv/usbdrv.c ****     8,                      /* max packet size */
 119:usbdrv/usbdrv.c ****     /* the following two casts affect the first byte of the constant only, but
 120:usbdrv/usbdrv.c ****      * that's sufficient to avoid a warning with the default values.
 121:usbdrv/usbdrv.c ****      */
 122:usbdrv/usbdrv.c ****     (char)USB_CFG_VENDOR_ID,/* 2 bytes */
 123:usbdrv/usbdrv.c ****     (char)USB_CFG_DEVICE_ID,/* 2 bytes */
 124:usbdrv/usbdrv.c ****     USB_CFG_DEVICE_VERSION, /* 2 bytes */
 125:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_VENDOR != 0 ? 1 : 0,         /* manufacturer string index */
 126:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_PRODUCT != 0 ? 2 : 0,        /* product string index */
 127:usbdrv/usbdrv.c ****     USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER != 0 ? 3 : 0,  /* serial number string index */
 128:usbdrv/usbdrv.c ****     1,          /* number of configurations */
 129:usbdrv/usbdrv.c **** };
 130:usbdrv/usbdrv.c **** #endif
 131:usbdrv/usbdrv.c **** 
 132:usbdrv/usbdrv.c **** /* ----------------------- Configuration Descriptor ------------------------ */
 133:usbdrv/usbdrv.c **** 
 134:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT != 0 && USB_CFG_DESCR_PROPS_HID == 0
 135:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_HID
 136:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_HID     9   /* length of HID descriptor in config descriptor below */
 137:usbdrv/usbdrv.c **** #endif
 138:usbdrv/usbdrv.c **** 
 139:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_CONFIGURATION == 0
 140:usbdrv/usbdrv.c **** #undef USB_CFG_DESCR_PROPS_CONFIGURATION
 141:usbdrv/usbdrv.c **** #define USB_CFG_DESCR_PROPS_CONFIGURATION   sizeof(usbDescriptorConfiguration)
 142:usbdrv/usbdrv.c **** PROGMEM const char usbDescriptorConfiguration[] = {    /* USB configuration descriptor */
 143:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescriptorConfiguration): length of descriptor in bytes */
 144:usbdrv/usbdrv.c ****     USBDESCR_CONFIG,    /* descriptor type */
 145:usbdrv/usbdrv.c ****     18 + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT + 7 * USB_CFG_HAVE_INTRIN_ENDPOINT3 +
 146:usbdrv/usbdrv.c ****                 (USB_CFG_DESCR_PROPS_HID & 0xff), 0,
 147:usbdrv/usbdrv.c ****                 /* total length of data returned (including inlined descriptors) */
 148:usbdrv/usbdrv.c ****     1,          /* number of interfaces in this configuration */
 149:usbdrv/usbdrv.c ****     1,          /* index of this configuration */
 150:usbdrv/usbdrv.c ****     0,          /* configuration name string index */
 151:usbdrv/usbdrv.c **** #if USB_CFG_IS_SELF_POWERED
 152:usbdrv/usbdrv.c ****     (1 << 7) | USBATTR_SELFPOWER,       /* attributes */
 153:usbdrv/usbdrv.c **** #else
 154:usbdrv/usbdrv.c ****     (1 << 7),                           /* attributes */
 155:usbdrv/usbdrv.c **** #endif
 156:usbdrv/usbdrv.c ****     USB_CFG_MAX_BUS_POWER/2,            /* max USB current in 2mA units */
 157:usbdrv/usbdrv.c **** /* interface descriptor follows inline: */
 158:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrInterface): length of descriptor in bytes */
 159:usbdrv/usbdrv.c ****     USBDESCR_INTERFACE, /* descriptor type */
 160:usbdrv/usbdrv.c ****     0,          /* index of this interface */
 161:usbdrv/usbdrv.c ****     0,          /* alternate setting for this interface */
 162:usbdrv/usbdrv.c ****     USB_CFG_HAVE_INTRIN_ENDPOINT + USB_CFG_HAVE_INTRIN_ENDPOINT3, /* endpoints excl 0: number of en
 163:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_CLASS,
 164:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_SUBCLASS,
GAS LISTING /tmp/ccBGRCFe.s 			page 6


 165:usbdrv/usbdrv.c ****     USB_CFG_INTERFACE_PROTOCOL,
 166:usbdrv/usbdrv.c ****     0,          /* string index for interface */
 167:usbdrv/usbdrv.c **** #if (USB_CFG_DESCR_PROPS_HID & 0xff)    /* HID descriptor */
 168:usbdrv/usbdrv.c ****     9,          /* sizeof(usbDescrHID): length of descriptor in bytes */
 169:usbdrv/usbdrv.c ****     USBDESCR_HID,   /* descriptor type: HID */
 170:usbdrv/usbdrv.c ****     0x01, 0x01, /* BCD representation of HID version */
 171:usbdrv/usbdrv.c ****     0x00,       /* target country code */
 172:usbdrv/usbdrv.c ****     0x01,       /* number of HID Report (or other HID class) Descriptor infos to follow */
 173:usbdrv/usbdrv.c ****     0x22,       /* descriptor type: report */
 174:usbdrv/usbdrv.c ****     USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH, 0,  /* total length of report descriptor */
 175:usbdrv/usbdrv.c **** #endif
 176:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT    /* endpoint descriptor for endpoint 1 */
 177:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 178:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 179:usbdrv/usbdrv.c ****     (char)0x81, /* IN endpoint number 1 */
 180:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 181:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 182:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 183:usbdrv/usbdrv.c **** #endif
 184:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3   /* endpoint descriptor for endpoint 3 */
 185:usbdrv/usbdrv.c ****     7,          /* sizeof(usbDescrEndpoint) */
 186:usbdrv/usbdrv.c ****     USBDESCR_ENDPOINT,  /* descriptor type = endpoint */
 187:usbdrv/usbdrv.c ****     (char)0x83, /* IN endpoint number 1 */
 188:usbdrv/usbdrv.c ****     0x03,       /* attrib: Interrupt endpoint */
 189:usbdrv/usbdrv.c ****     8, 0,       /* maximum packet size */
 190:usbdrv/usbdrv.c ****     USB_CFG_INTR_POLL_INTERVAL, /* in ms */
 191:usbdrv/usbdrv.c **** #endif
 192:usbdrv/usbdrv.c **** };
 193:usbdrv/usbdrv.c **** #endif
 194:usbdrv/usbdrv.c **** 
 195:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 196:usbdrv/usbdrv.c **** 
 197:usbdrv/usbdrv.c **** static inline void  usbResetDataToggling(void)
 198:usbdrv/usbdrv.c **** {
 199:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 201:usbdrv/usbdrv.c **** #   if USB_CFG_HAVE_INTRIN_ENDPOINT3
 202:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN3(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 203:usbdrv/usbdrv.c **** #   endif
 204:usbdrv/usbdrv.c **** #endif
 205:usbdrv/usbdrv.c **** }
 206:usbdrv/usbdrv.c **** 
 207:usbdrv/usbdrv.c **** static inline void  usbResetStall(void)
 208:usbdrv/usbdrv.c **** {
 209:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT && USB_CFG_HAVE_INTRIN_ENDPOINT
 210:usbdrv/usbdrv.c ****         usbTxLen1 = USBPID_NAK;
 211:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 212:usbdrv/usbdrv.c ****         usbTxLen3 = USBPID_NAK;
 213:usbdrv/usbdrv.c **** #endif
 214:usbdrv/usbdrv.c **** #endif
 215:usbdrv/usbdrv.c **** }
 216:usbdrv/usbdrv.c **** 
 217:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 218:usbdrv/usbdrv.c **** 
 219:usbdrv/usbdrv.c **** #if !USB_CFG_SUPPRESS_INTR_CODE
 220:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT
 221:usbdrv/usbdrv.c **** static void usbGenericSetInterrupt(uchar *data, uchar len, usbTxStatus_t *txStatus)
GAS LISTING /tmp/ccBGRCFe.s 			page 7


 222:usbdrv/usbdrv.c **** {
 223:usbdrv/usbdrv.c **** uchar   *p;
 224:usbdrv/usbdrv.c **** char    i;
 225:usbdrv/usbdrv.c **** 
 226:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 227:usbdrv/usbdrv.c ****     if(usbTxLen1 == USBPID_STALL)
 228:usbdrv/usbdrv.c ****         return;
 229:usbdrv/usbdrv.c **** #endif
 230:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 231:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 232:usbdrv/usbdrv.c ****     }else{
 233:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 234:usbdrv/usbdrv.c ****     }
 235:usbdrv/usbdrv.c ****     p = txStatus->buffer + 1;
 236:usbdrv/usbdrv.c ****     i = len;
 237:usbdrv/usbdrv.c ****     do{                         /* if len == 0, we still copy 1 byte, but that's no problem */
 238:usbdrv/usbdrv.c ****         *p++ = *data++;
 239:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 240:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 241:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 242:usbdrv/usbdrv.c ****     DBG2(0x21 + (((int)txStatus >> 3) & 3), txStatus->buffer, len + 3);
 243:usbdrv/usbdrv.c **** }
 244:usbdrv/usbdrv.c **** 
 245:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt(uchar *data, uchar len)
 246:usbdrv/usbdrv.c **** {
 122               		.stabn	68,0,246,.LM0-.LFBB1
 123               	.LM0:
 124               	.LFBB1:
 125 0000 CF93      		push r28
 126               	/* prologue: function */
 127               	/* frame size = 0 */
 128               	/* stack size = 1 */
 129               	.L__stack_usage = 1
 130 0002 C62F      		mov r28,r22
 131               	.LBB22:
 132               	.LBB23:
 230:usbdrv/usbdrv.c ****     if(txStatus->len & 0x10){   /* packet buffer was empty */
 133               		.stabn	68,0,230,.LM1-.LFBB1
 134               	.LM1:
 135 0004 2091 0000 		lds r18,usbTxStatus1
 136 0008 24FF      		sbrs r18,4
 137 000a 00C0      		rjmp .L2
 231:usbdrv/usbdrv.c ****         txStatus->buffer[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* toggle token */
 138               		.stabn	68,0,231,.LM2-.LFBB1
 139               	.LM2:
 140 000c 2091 0000 		lds r18,usbTxStatus1+1
 141 0010 38E8      		ldi r19,lo8(-120)
 142 0012 2327      		eor r18,r19
 143 0014 2093 0000 		sts usbTxStatus1+1,r18
 144 0018 00C0      		rjmp .L3
 145               	.L2:
 233:usbdrv/usbdrv.c ****         txStatus->len = USBPID_NAK; /* avoid sending outdated (overwritten) interrupt data */
 146               		.stabn	68,0,233,.LM3-.LFBB1
 147               	.LM3:
 148 001a 2AE5      		ldi r18,lo8(90)
 149 001c 2093 0000 		sts usbTxStatus1,r18
 150               	.L3:
GAS LISTING /tmp/ccBGRCFe.s 			page 8


 151 0020 DC01      		movw r26,r24
 152               	.LBE23:
 153               	.LBE22:
 154               		.stabn	68,0,246,.LM4-.LFBB1
 155               	.LM4:
 156 0022 E0E0      		ldi r30,lo8(usbTxStatus1+2)
 157 0024 F0E0      		ldi r31,hi8(usbTxStatus1+2)
 158 0026 8C2F      		mov r24,r28
 159 0028 8E0F      		add r24,r30
 160               	.L5:
 161               	.LBB25:
 162               	.LBB24:
 238:usbdrv/usbdrv.c ****         *p++ = *data++;
 163               		.stabn	68,0,238,.LM5-.LFBB1
 164               	.LM5:
 165 002a 9D91      		ld r25,X+
 166 002c 9193      		st Z+,r25
 239:usbdrv/usbdrv.c ****     }while(--i > 0);            /* loop control at the end is 2 bytes shorter than at beginning */
 167               		.stabn	68,0,239,.LM6-.LFBB1
 168               	.LM6:
 169 002e 8E13      		cpse r24,r30
 170 0030 00C0      		rjmp .L5
 240:usbdrv/usbdrv.c ****     usbCrc16Append(&txStatus->buffer[1], len);
 171               		.stabn	68,0,240,.LM7-.LFBB1
 172               	.LM7:
 173 0032 6C2F      		mov r22,r28
 174 0034 80E0      		ldi r24,lo8(usbTxStatus1+2)
 175 0036 90E0      		ldi r25,hi8(usbTxStatus1+2)
 176 0038 00D0      		rcall usbCrc16Append
 241:usbdrv/usbdrv.c ****     txStatus->len = len + 4;    /* len must be given including sync byte */
 177               		.stabn	68,0,241,.LM8-.LFBB1
 178               	.LM8:
 179 003a CC5F      		subi r28,lo8(-(4))
 180 003c C093 0000 		sts usbTxStatus1,r28
 181               	/* epilogue start */
 182               	.LBE24:
 183               	.LBE25:
 247:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus1);
 248:usbdrv/usbdrv.c **** }
 184               		.stabn	68,0,248,.LM9-.LFBB1
 185               	.LM9:
 186 0040 CF91      		pop r28
 187 0042 0895      		ret
 188               		.size	usbSetInterrupt, .-usbSetInterrupt
 189               	.Lscope1:
 190               		.stabs	"",36,0,0,.Lscope1-.LFBB1
 191               		.stabd	78,0,0
 192               		.stabs	"usbPoll:F(0,47)",36,0,566,usbPoll
 193               	.global	usbPoll
 194               		.type	usbPoll, @function
 195               	usbPoll:
 196               		.stabd	46,0,0
 249:usbdrv/usbdrv.c **** #endif
 250:usbdrv/usbdrv.c **** 
 251:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT3
 252:usbdrv/usbdrv.c **** USB_PUBLIC void usbSetInterrupt3(uchar *data, uchar len)
 253:usbdrv/usbdrv.c **** {
GAS LISTING /tmp/ccBGRCFe.s 			page 9


 254:usbdrv/usbdrv.c ****     usbGenericSetInterrupt(data, len, &usbTxStatus3);
 255:usbdrv/usbdrv.c **** }
 256:usbdrv/usbdrv.c **** #endif
 257:usbdrv/usbdrv.c **** #endif /* USB_CFG_SUPPRESS_INTR_CODE */
 258:usbdrv/usbdrv.c **** 
 259:usbdrv/usbdrv.c **** /* ------------------ utilities for code following below ------------------- */
 260:usbdrv/usbdrv.c **** 
 261:usbdrv/usbdrv.c **** /* Use defines for the switch statement so that we can choose between an
 262:usbdrv/usbdrv.c ****  * if()else if() and a switch/case based implementation. switch() is more
 263:usbdrv/usbdrv.c ****  * efficient for a LARGE set of sequential choices, if() is better in all other
 264:usbdrv/usbdrv.c ****  * cases.
 265:usbdrv/usbdrv.c ****  */
 266:usbdrv/usbdrv.c **** #if USB_CFG_USE_SWITCH_STATEMENT
 267:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       switch(cmd){{
 268:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }break; case (value):{
 269:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }break; case (v1): case(v2):{
 270:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }break; case (v1): case(v2): case(v3):{
 271:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }break; default:{
 272:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 273:usbdrv/usbdrv.c **** #else
 274:usbdrv/usbdrv.c **** #   define SWITCH_START(cmd)       {uchar _cmd = cmd; if(0){
 275:usbdrv/usbdrv.c **** #   define SWITCH_CASE(value)      }else if(_cmd == (value)){
 276:usbdrv/usbdrv.c **** #   define SWITCH_CASE2(v1,v2)     }else if(_cmd == (v1) || _cmd == (v2)){
 277:usbdrv/usbdrv.c **** #   define SWITCH_CASE3(v1,v2,v3)  }else if(_cmd == (v1) || _cmd == (v2) || (_cmd == v3)){
 278:usbdrv/usbdrv.c **** #   define SWITCH_DEFAULT          }else{
 279:usbdrv/usbdrv.c **** #   define SWITCH_END              }}
 280:usbdrv/usbdrv.c **** #endif
 281:usbdrv/usbdrv.c **** 
 282:usbdrv/usbdrv.c **** #ifndef USB_RX_USER_HOOK
 283:usbdrv/usbdrv.c **** #define USB_RX_USER_HOOK(data, len)
 284:usbdrv/usbdrv.c **** #endif
 285:usbdrv/usbdrv.c **** #ifndef USB_SET_ADDRESS_HOOK
 286:usbdrv/usbdrv.c **** #define USB_SET_ADDRESS_HOOK()
 287:usbdrv/usbdrv.c **** #endif
 288:usbdrv/usbdrv.c **** 
 289:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 290:usbdrv/usbdrv.c **** 
 291:usbdrv/usbdrv.c **** /* We use if() instead of #if in the macro below because #if can't be used
 292:usbdrv/usbdrv.c ****  * in macros and the compiler optimizes constant conditions anyway.
 293:usbdrv/usbdrv.c ****  * This may cause problems with undefined symbols if compiled without
 294:usbdrv/usbdrv.c ****  * optimizing!
 295:usbdrv/usbdrv.c ****  */
 296:usbdrv/usbdrv.c **** #define GET_DESCRIPTOR(cfgProp, staticName)         \
 297:usbdrv/usbdrv.c ****     if(cfgProp){                                    \
 298:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_RAM)             \
 299:usbdrv/usbdrv.c ****             flags = 0;                              \
 300:usbdrv/usbdrv.c ****         if((cfgProp) & USB_PROP_IS_DYNAMIC){        \
 301:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);        \
 302:usbdrv/usbdrv.c ****         }else{                                      \
 303:usbdrv/usbdrv.c ****             len = USB_PROP_LENGTH(cfgProp);         \
 304:usbdrv/usbdrv.c ****             usbMsgPtr = (uchar *)(staticName);      \
 305:usbdrv/usbdrv.c ****         }                                           \
 306:usbdrv/usbdrv.c ****     }
 307:usbdrv/usbdrv.c **** 
 308:usbdrv/usbdrv.c **** /* usbDriverDescriptor() is similar to usbFunctionDescriptor(), but used
 309:usbdrv/usbdrv.c ****  * internally for all types of descriptors.
 310:usbdrv/usbdrv.c ****  */
GAS LISTING /tmp/ccBGRCFe.s 			page 10


 311:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverDescriptor(usbRequest_t *rq)
 312:usbdrv/usbdrv.c **** {
 313:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 314:usbdrv/usbdrv.c **** uchar       flags = USB_FLG_MSGPTR_IS_ROM;
 315:usbdrv/usbdrv.c **** 
 316:usbdrv/usbdrv.c ****     SWITCH_START(rq->wValue.bytes[1])
 317:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 318:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 319:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 320:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 321:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 322:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC
 323:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_RAM)
 324:usbdrv/usbdrv.c ****             flags = 0;
 325:usbdrv/usbdrv.c ****         len = usbFunctionDescriptor(rq);
 326:usbdrv/usbdrv.c **** #else   /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 327:usbdrv/usbdrv.c ****         SWITCH_START(rq->wValue.bytes[0])
 328:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 329:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 330:usbdrv/usbdrv.c ****         SWITCH_CASE(1)
 331:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_VENDOR, usbDescriptorStringVendor)
 332:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 333:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 334:usbdrv/usbdrv.c ****         SWITCH_CASE(3)
 335:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_SERIAL_NUMBER, usbDescriptorStringSerialNumbe
 336:usbdrv/usbdrv.c ****         SWITCH_DEFAULT
 337:usbdrv/usbdrv.c ****             if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 338:usbdrv/usbdrv.c ****                 len = usbFunctionDescriptor(rq);
 339:usbdrv/usbdrv.c ****             }
 340:usbdrv/usbdrv.c ****         SWITCH_END
 341:usbdrv/usbdrv.c **** #endif  /* USB_CFG_DESCR_PROPS_STRINGS & USB_PROP_IS_DYNAMIC */
 342:usbdrv/usbdrv.c **** #if USB_CFG_DESCR_PROPS_HID_REPORT  /* only support HID descriptors if enabled */
 343:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID)       /* 0x21 */
 344:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID, usbDescriptorConfiguration + 18)
 345:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_HID_REPORT)/* 0x22 */
 346:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_HID_REPORT, usbDescriptorHidReport)
 347:usbdrv/usbdrv.c **** #endif
 348:usbdrv/usbdrv.c ****     SWITCH_DEFAULT
 349:usbdrv/usbdrv.c ****         if(USB_CFG_DESCR_PROPS_UNKNOWN & USB_PROP_IS_DYNAMIC){
 350:usbdrv/usbdrv.c ****             len = usbFunctionDescriptor(rq);
 351:usbdrv/usbdrv.c ****         }
 352:usbdrv/usbdrv.c ****     SWITCH_END
 353:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 354:usbdrv/usbdrv.c ****     return len;
 355:usbdrv/usbdrv.c **** }
 356:usbdrv/usbdrv.c **** 
 357:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 358:usbdrv/usbdrv.c **** 
 359:usbdrv/usbdrv.c **** /* usbDriverSetup() is similar to usbFunctionSetup(), but it's used for
 360:usbdrv/usbdrv.c ****  * standard requests instead of class and custom requests.
 361:usbdrv/usbdrv.c ****  */
 362:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
 363:usbdrv/usbdrv.c **** {
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 365:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 366:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 367:usbdrv/usbdrv.c **** uchar   index = rq->wIndex.bytes[0];
GAS LISTING /tmp/ccBGRCFe.s 			page 11


 368:usbdrv/usbdrv.c **** #endif
 369:usbdrv/usbdrv.c **** 
 370:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 371:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 372:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 373:usbdrv/usbdrv.c ****         uchar recipient = rq->bmRequestType & USBRQ_RCPT_MASK;  /* assign arith ops to variables to
 374:usbdrv/usbdrv.c ****         if(USB_CFG_IS_SELF_POWERED && recipient == USBRQ_RCPT_DEVICE)
 375:usbdrv/usbdrv.c ****             dataPtr[0] =  USB_CFG_IS_SELF_POWERED;
 376:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 377:usbdrv/usbdrv.c ****         if(recipient == USBRQ_RCPT_ENDPOINT && index == 0x81)   /* request status for endpoint 1 */
 378:usbdrv/usbdrv.c ****             dataPtr[0] = usbTxLen1 == USBPID_STALL;
 379:usbdrv/usbdrv.c **** #endif
 380:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 381:usbdrv/usbdrv.c ****         len = 2;
 382:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_HALT
 383:usbdrv/usbdrv.c ****     SWITCH_CASE2(USBRQ_CLEAR_FEATURE, USBRQ_SET_FEATURE)    /* 1, 3 */
 384:usbdrv/usbdrv.c ****         if(value == 0 && index == 0x81){    /* feature 0 == HALT for endpoint == 1 */
 385:usbdrv/usbdrv.c ****             usbTxLen1 = rq->bRequest == USBRQ_CLEAR_FEATURE ? USBPID_NAK : USBPID_STALL;
 386:usbdrv/usbdrv.c ****             usbResetDataToggling();
 387:usbdrv/usbdrv.c ****         }
 388:usbdrv/usbdrv.c **** #endif
 389:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 390:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 391:usbdrv/usbdrv.c ****         USB_SET_ADDRESS_HOOK();
 392:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 393:usbdrv/usbdrv.c ****         len = usbDriverDescriptor(rq);
 394:usbdrv/usbdrv.c ****         goto skipMsgPtrAssignment;
 395:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 396:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 397:usbdrv/usbdrv.c ****         len = 1;
 398:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 399:usbdrv/usbdrv.c ****         usbConfiguration = value;
 400:usbdrv/usbdrv.c ****         usbResetStall();
 401:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 402:usbdrv/usbdrv.c ****         len = 1;
 403:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 404:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 405:usbdrv/usbdrv.c ****         usbResetDataToggling();
 406:usbdrv/usbdrv.c ****         usbResetStall();
 407:usbdrv/usbdrv.c **** #endif
 408:usbdrv/usbdrv.c ****     SWITCH_DEFAULT                          /* 7=SET_DESCRIPTOR, 12=SYNC_FRAME */
 409:usbdrv/usbdrv.c ****         /* Should we add an optional hook here? */
 410:usbdrv/usbdrv.c ****     SWITCH_END
 411:usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 412:usbdrv/usbdrv.c **** skipMsgPtrAssignment:
 413:usbdrv/usbdrv.c ****     return len;
 414:usbdrv/usbdrv.c **** }
 415:usbdrv/usbdrv.c **** 
 416:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 417:usbdrv/usbdrv.c **** 
 418:usbdrv/usbdrv.c **** /* usbProcessRx() is called for every message received by the interrupt
 419:usbdrv/usbdrv.c ****  * routine. It distinguishes between SETUP and DATA packets and processes
 420:usbdrv/usbdrv.c ****  * them accordingly.
 421:usbdrv/usbdrv.c ****  */
 422:usbdrv/usbdrv.c **** static inline void usbProcessRx(uchar *data, uchar len)
 423:usbdrv/usbdrv.c **** {
 424:usbdrv/usbdrv.c **** usbRequest_t    *rq = (void *)data;
GAS LISTING /tmp/ccBGRCFe.s 			page 12


 425:usbdrv/usbdrv.c **** 
 426:usbdrv/usbdrv.c **** /* usbRxToken can be:
 427:usbdrv/usbdrv.c ****  * 0x2d 00101101 (USBPID_SETUP for setup data)
 428:usbdrv/usbdrv.c ****  * 0xe1 11100001 (USBPID_OUT: data phase of setup transfer)
 429:usbdrv/usbdrv.c ****  * 0...0x0f for OUT on endpoint X
 430:usbdrv/usbdrv.c ****  */
 431:usbdrv/usbdrv.c ****     DBG2(0x10 + (usbRxToken & 0xf), data, len + 2); /* SETUP=1d, SETUP-DATA=11, OUTx=1x */
 432:usbdrv/usbdrv.c ****     USB_RX_USER_HOOK(data, len)
 433:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITEOUT
 434:usbdrv/usbdrv.c ****     if(usbRxToken < 0x10){  /* OUT to endpoint != 0: endpoint number in usbRxToken */
 435:usbdrv/usbdrv.c ****         usbFunctionWriteOut(data, len);
 436:usbdrv/usbdrv.c ****         return;
 437:usbdrv/usbdrv.c ****     }
 438:usbdrv/usbdrv.c **** #endif
 439:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 440:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 441:usbdrv/usbdrv.c ****             return;
 442:usbdrv/usbdrv.c ****         usbMsgLen_t replyLen;
 443:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 444:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 445:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 446:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 447:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 448:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 449:usbdrv/usbdrv.c **** 			// 2010.04.29 chrisc need this to work w/ usbtiny
 450:usbdrv/usbdrv.c ****         }else{
 451:usbdrv/usbdrv.c ****             replyLen = usbDriverSetup(rq);
 452:usbdrv/usbdrv.c ****         }
 453:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ || USB_CFG_IMPLEMENT_FN_WRITE
 454:usbdrv/usbdrv.c ****         if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 455:usbdrv/usbdrv.c ****             /* do some conditioning on replyLen, but on IN transfers only */
 456:usbdrv/usbdrv.c ****             if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 457:usbdrv/usbdrv.c ****                 if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing *
 458:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 459:usbdrv/usbdrv.c ****                 }else{
 460:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.word;
 461:usbdrv/usbdrv.c ****                 }
 462:usbdrv/usbdrv.c ****             }
 463:usbdrv/usbdrv.c ****             usbMsgFlags = USB_FLG_USE_USER_RW;
 464:usbdrv/usbdrv.c ****         }else   /* The 'else' prevents that we limit a replyLen of USB_NO_MSG to the maximum transf
 465:usbdrv/usbdrv.c **** #endif
 466:usbdrv/usbdrv.c ****         if(sizeof(replyLen) < sizeof(rq->wLength.word)){ /* help compiler with optimizing */
 467:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 468:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.bytes[0];
 469:usbdrv/usbdrv.c ****         }else{
 470:usbdrv/usbdrv.c ****             if(replyLen > rq->wLength.word)     /* limit length to max */
 471:usbdrv/usbdrv.c ****                 replyLen = rq->wLength.word;
 472:usbdrv/usbdrv.c ****         }
 473:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 474:usbdrv/usbdrv.c ****     }else{  /* usbRxToken must be USBPID_OUT, which means data phase of setup (control-out) */
 475:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_WRITE
 476:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 477:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 478:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 479:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 480:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 481:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
GAS LISTING /tmp/ccBGRCFe.s 			page 13


 482:usbdrv/usbdrv.c ****             }
 483:usbdrv/usbdrv.c ****         }
 484:usbdrv/usbdrv.c **** #endif
 485:usbdrv/usbdrv.c ****     }
 486:usbdrv/usbdrv.c **** }
 487:usbdrv/usbdrv.c **** 
 488:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 489:usbdrv/usbdrv.c **** 
 490:usbdrv/usbdrv.c **** /* This function is similar to usbFunctionRead(), but it's also called for
 491:usbdrv/usbdrv.c ****  * data handled automatically by the driver (e.g. descriptor reads).
 492:usbdrv/usbdrv.c ****  */
 493:usbdrv/usbdrv.c **** static uchar usbDeviceRead(uchar *data, uchar len)
 494:usbdrv/usbdrv.c **** {
 495:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 496:usbdrv/usbdrv.c **** #if USB_CFG_IMPLEMENT_FN_READ
 497:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 498:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 499:usbdrv/usbdrv.c ****         }else
 500:usbdrv/usbdrv.c **** #endif
 501:usbdrv/usbdrv.c ****         {
 502:usbdrv/usbdrv.c ****             uchar i = len, *r = usbMsgPtr;
 503:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 504:usbdrv/usbdrv.c ****                 do{
 505:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 506:usbdrv/usbdrv.c ****                     *data++ = c;
 507:usbdrv/usbdrv.c ****                     r++;
 508:usbdrv/usbdrv.c ****                 }while(--i);
 509:usbdrv/usbdrv.c ****             }else{  /* RAM data */
 510:usbdrv/usbdrv.c ****                 do{
 511:usbdrv/usbdrv.c ****                     *data++ = *r++;
 512:usbdrv/usbdrv.c ****                 }while(--i);
 513:usbdrv/usbdrv.c ****             }
 514:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 515:usbdrv/usbdrv.c ****         }
 516:usbdrv/usbdrv.c ****     }
 517:usbdrv/usbdrv.c ****     return len;
 518:usbdrv/usbdrv.c **** }
 519:usbdrv/usbdrv.c **** 
 520:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 521:usbdrv/usbdrv.c **** 
 522:usbdrv/usbdrv.c **** /* usbBuildTxBlock() is called when we have data to transmit and the
 523:usbdrv/usbdrv.c ****  * interrupt routine's transmit buffer is empty.
 524:usbdrv/usbdrv.c ****  */
 525:usbdrv/usbdrv.c **** static inline void usbBuildTxBlock(void)
 526:usbdrv/usbdrv.c **** {
 527:usbdrv/usbdrv.c **** usbMsgLen_t wantLen;
 528:usbdrv/usbdrv.c **** uchar       len;
 529:usbdrv/usbdrv.c **** 
 530:usbdrv/usbdrv.c ****     wantLen = usbMsgLen;
 531:usbdrv/usbdrv.c ****     if(wantLen > 8)
 532:usbdrv/usbdrv.c ****         wantLen = 8;
 533:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
 534:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 535:usbdrv/usbdrv.c ****     len = usbDeviceRead(usbTxBuf + 1, wantLen);
 536:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 537:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 538:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
GAS LISTING /tmp/ccBGRCFe.s 			page 14


 539:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 540:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 541:usbdrv/usbdrv.c ****     }else{
 542:usbdrv/usbdrv.c ****         len = USBPID_STALL;   /* stall the endpoint */
 543:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 544:usbdrv/usbdrv.c ****     }
 545:usbdrv/usbdrv.c ****     usbTxLen = len;
 546:usbdrv/usbdrv.c ****     DBG2(0x20, usbTxBuf, len-1);
 547:usbdrv/usbdrv.c **** }
 548:usbdrv/usbdrv.c **** 
 549:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 550:usbdrv/usbdrv.c **** 
 551:usbdrv/usbdrv.c **** static inline void usbHandleResetHook(uchar notResetState)
 552:usbdrv/usbdrv.c **** {
 553:usbdrv/usbdrv.c **** #ifdef USB_RESET_HOOK
 554:usbdrv/usbdrv.c **** static uchar    wasReset;
 555:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 556:usbdrv/usbdrv.c **** 
 557:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 558:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 559:usbdrv/usbdrv.c ****         wasReset = isReset;
 560:usbdrv/usbdrv.c ****     }
 561:usbdrv/usbdrv.c **** #endif
 562:usbdrv/usbdrv.c **** }
 563:usbdrv/usbdrv.c **** 
 564:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 565:usbdrv/usbdrv.c **** 
 566:usbdrv/usbdrv.c **** USB_PUBLIC void usbPoll(void)
 567:usbdrv/usbdrv.c **** {
 197               		.stabn	68,0,567,.LM10-.LFBB2
 198               	.LM10:
 199               	.LFBB2:
 200 0044 CF93      		push r28
 201 0046 DF93      		push r29
 202               	/* prologue: function */
 203               	/* frame size = 0 */
 204               	/* stack size = 2 */
 205               	.L__stack_usage = 2
 568:usbdrv/usbdrv.c **** schar   len;
 569:usbdrv/usbdrv.c **** uchar   i;
 570:usbdrv/usbdrv.c **** 
 571:usbdrv/usbdrv.c ****     len = usbRxLen - 3;
 206               		.stabn	68,0,571,.LM11-.LFBB2
 207               	.LM11:
 208 0048 6091 0000 		lds r22,usbRxLen
 209 004c 6350      		subi r22,lo8(-(-3))
 572:usbdrv/usbdrv.c ****     if(len >= 0){
 210               		.stabn	68,0,572,.LM12-.LFBB2
 211               	.LM12:
 212 004e 67FD      		sbrc r22,7
 213 0050 00C0      		rjmp .L8
 573:usbdrv/usbdrv.c **** /* We could check CRC16 here -- but ACK has already been sent anyway. If you
 574:usbdrv/usbdrv.c ****  * need data integrity checks with this driver, check the CRC in your app
 575:usbdrv/usbdrv.c ****  * code and report errors back to the host. Since the ACK was already sent,
 576:usbdrv/usbdrv.c ****  * retries must be handled on application level.
 577:usbdrv/usbdrv.c ****  * unsigned crc = usbCrc16(buffer + 1, usbRxLen - 3);
 578:usbdrv/usbdrv.c ****  */
GAS LISTING /tmp/ccBGRCFe.s 			page 15


 579:usbdrv/usbdrv.c ****         usbProcessRx(usbRxBuf + USB_BUFSIZE + 1 - usbInputBufOffset, len);
 214               		.stabn	68,0,579,.LM13-.LFBB2
 215               	.LM13:
 216 0052 8091 0000 		lds r24,usbInputBufOffset
 217 0056 CCE0      		ldi r28,lo8(12)
 218 0058 D0E0      		ldi r29,0
 219 005a C81B      		sub r28,r24
 220 005c D109      		sbc r29,__zero_reg__
 221 005e C050      		subi r28,lo8(-(usbRxBuf))
 222 0060 D040      		sbci r29,hi8(-(usbRxBuf))
 223               	.LBB50:
 224               	.LBB51:
 439:usbdrv/usbdrv.c ****     if(usbRxToken == (uchar)USBPID_SETUP){
 225               		.stabn	68,0,439,.LM14-.LFBB2
 226               	.LM14:
 227 0062 8091 0000 		lds r24,usbRxToken
 228 0066 8D32      		cpi r24,lo8(45)
 229 0068 01F0      		breq .+2
 230 006a 00C0      		rjmp .L9
 231               	.LBB52:
 440:usbdrv/usbdrv.c ****         if(len != 8)    /* Setup size must be always 8 bytes. Ignore otherwise. */
 232               		.stabn	68,0,440,.LM15-.LFBB2
 233               	.LM15:
 234 006c 6830      		cpi r22,lo8(8)
 235 006e 01F0      		breq .+2
 236 0070 00C0      		rjmp .L11
 443:usbdrv/usbdrv.c ****         usbTxBuf[0] = USBPID_DATA0;         /* initialize data toggling */
 237               		.stabn	68,0,443,.LM16-.LFBB2
 238               	.LM16:
 239 0072 83EC      		ldi r24,lo8(-61)
 240 0074 8093 0000 		sts usbTxBuf,r24
 444:usbdrv/usbdrv.c ****         usbTxLen = USBPID_NAK;              /* abort pending transmit */
 241               		.stabn	68,0,444,.LM17-.LFBB2
 242               	.LM17:
 243 0078 8AE5      		ldi r24,lo8(90)
 244 007a 8093 0000 		sts usbTxLen,r24
 445:usbdrv/usbdrv.c ****         usbMsgFlags = 0;
 245               		.stabn	68,0,445,.LM18-.LFBB2
 246               	.LM18:
 247 007e 1092 0000 		sts usbMsgFlags,__zero_reg__
 446:usbdrv/usbdrv.c ****         uchar type = rq->bmRequestType & USBRQ_TYPE_MASK;
 248               		.stabn	68,0,446,.LM19-.LFBB2
 249               	.LM19:
 250 0082 8881      		ld r24,Y
 251 0084 8076      		andi r24,lo8(96)
 447:usbdrv/usbdrv.c ****         if(type != USBRQ_TYPE_STANDARD){    /* standard requests are handled by driver */
 252               		.stabn	68,0,447,.LM20-.LFBB2
 253               	.LM20:
 254 0086 01F0      		breq .L12
 448:usbdrv/usbdrv.c ****             replyLen = usbFunctionSetup(data);
 255               		.stabn	68,0,448,.LM21-.LFBB2
 256               	.LM21:
 257 0088 CE01      		movw r24,r28
 258 008a 00D0      		rcall usbFunctionSetup
 454:usbdrv/usbdrv.c ****         if(replyLen == USB_NO_MSG){         /* use user-supplied read/write function */
 259               		.stabn	68,0,454,.LM22-.LFBB2
 260               	.LM22:
GAS LISTING /tmp/ccBGRCFe.s 			page 16


 261 008c 8F3F      		cpi r24,lo8(-1)
 262 008e 01F4      		brne .+2
 263 0090 00C0      		rjmp .L13
 264 0092 00C0      		rjmp .L14
 265               	.L12:
 266               	.LBB53:
 267               	.LBB54:
 365:usbdrv/usbdrv.c **** uchar   value = rq->wValue.bytes[0];
 268               		.stabn	68,0,365,.LM23-.LFBB2
 269               	.LM23:
 270 0094 9A81      		ldd r25,Y+2
 370:usbdrv/usbdrv.c ****     dataPtr[0] = 0; /* default reply common to USBRQ_GET_STATUS and USBRQ_GET_INTERFACE */
 271               		.stabn	68,0,370,.LM24-.LFBB2
 272               	.LM24:
 273 0096 1092 0000 		sts usbTxBuf+9,__zero_reg__
 274               	.LBB55:
 371:usbdrv/usbdrv.c ****     SWITCH_START(rq->bRequest)
 275               		.stabn	68,0,371,.LM25-.LFBB2
 276               	.LM25:
 277 009a 8981      		ldd r24,Y+1
 372:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_STATUS)           /* 0 */
 278               		.stabn	68,0,372,.LM26-.LFBB2
 279               	.LM26:
 280 009c 8111      		cpse r24,__zero_reg__
 281 009e 00C0      		rjmp .L15
 282               	.LBB56:
 380:usbdrv/usbdrv.c ****         dataPtr[1] = 0;
 283               		.stabn	68,0,380,.LM27-.LFBB2
 284               	.LM27:
 285 00a0 1092 0000 		sts usbTxBuf+10,__zero_reg__
 286               	.LBE56:
 287               	.LBE55:
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 288               		.stabn	68,0,364,.LM28-.LFBB2
 289               	.LM28:
 290 00a4 20E0      		ldi r18,lo8(usbTxBuf+9)
 291 00a6 30E0      		ldi r19,hi8(usbTxBuf+9)
 292               	.LBB64:
 293               	.LBB57:
 381:usbdrv/usbdrv.c ****         len = 2;
 294               		.stabn	68,0,381,.LM29-.LFBB2
 295               	.LM29:
 296 00a8 82E0      		ldi r24,lo8(2)
 297 00aa 00C0      		rjmp .L16
 298               	.L15:
 299               	.LBE57:
 389:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_ADDRESS)          /* 5 */
 300               		.stabn	68,0,389,.LM30-.LFBB2
 301               	.LM30:
 302 00ac 8530      		cpi r24,lo8(5)
 303 00ae 01F4      		brne .L17
 390:usbdrv/usbdrv.c ****         usbNewDeviceAddr = value;
 304               		.stabn	68,0,390,.LM31-.LFBB2
 305               	.LM31:
 306 00b0 9093 0000 		sts usbNewDeviceAddr,r25
 307 00b4 00C0      		rjmp .L52
 308               	.L17:
GAS LISTING /tmp/ccBGRCFe.s 			page 17


 392:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_DESCRIPTOR)       /* 6 */
 309               		.stabn	68,0,392,.LM32-.LFBB2
 310               	.LM32:
 311 00b6 8630      		cpi r24,lo8(6)
 312 00b8 01F4      		brne .L18
 313               	.LBE64:
 314               	.LBE54:
 315               	.LBE53:
 316               	.LBE52:
 317               	.LBE51:
 318               	.LBE50:
 362:usbdrv/usbdrv.c **** static inline usbMsgLen_t usbDriverSetup(usbRequest_t *rq)
 319               		.stabn	68,0,362,.LM33-.LFBB2
 320               	.LM33:
 321 00ba 8B81      		ldd r24,Y+3
 322               	.LBB72:
 323               	.LBB71:
 324               	.LBB69:
 325               	.LBB68:
 326               	.LBB67:
 327               	.LBB65:
 328               	.LBB58:
 329               	.LBB59:
 330               	.LBB60:
 317:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_DEVICE)    /* 1 */
 331               		.stabn	68,0,317,.LM34-.LFBB2
 332               	.LM34:
 333 00bc 8130      		cpi r24,lo8(1)
 334 00be 01F4      		brne .L19
 318:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_DEVICE, usbDescriptorDevice)
 335               		.stabn	68,0,318,.LM35-.LFBB2
 336               	.LM35:
 337 00c0 80E0      		ldi r24,lo8(usbDescriptorDevice)
 338 00c2 90E0      		ldi r25,hi8(usbDescriptorDevice)
 339 00c4 9093 0000 		sts usbMsgPtr+1,r25
 340 00c8 8093 0000 		sts usbMsgPtr,r24
 341 00cc 82E1      		ldi r24,lo8(18)
 342 00ce 00C0      		rjmp .L20
 343               	.L19:
 319:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_CONFIG)    /* 2 */
 344               		.stabn	68,0,319,.LM36-.LFBB2
 345               	.LM36:
 346 00d0 8230      		cpi r24,lo8(2)
 347 00d2 01F4      		brne .L21
 320:usbdrv/usbdrv.c ****         GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_CONFIGURATION, usbDescriptorConfiguration)
 348               		.stabn	68,0,320,.LM37-.LFBB2
 349               	.LM37:
 350 00d4 80E0      		ldi r24,lo8(usbDescriptorConfiguration)
 351 00d6 90E0      		ldi r25,hi8(usbDescriptorConfiguration)
 352 00d8 9093 0000 		sts usbMsgPtr+1,r25
 353 00dc 8093 0000 		sts usbMsgPtr,r24
 354 00e0 89E1      		ldi r24,lo8(25)
 355 00e2 00C0      		rjmp .L20
 356               	.L21:
 321:usbdrv/usbdrv.c ****     SWITCH_CASE(USBDESCR_STRING)    /* 3 */
 357               		.stabn	68,0,321,.LM38-.LFBB2
 358               	.LM38:
GAS LISTING /tmp/ccBGRCFe.s 			page 18


 359 00e4 8330      		cpi r24,lo8(3)
 360 00e6 01F4      		brne .L49
 361               	.LBB61:
 328:usbdrv/usbdrv.c ****         SWITCH_CASE(0)
 362               		.stabn	68,0,328,.LM39-.LFBB2
 363               	.LM39:
 364 00e8 9111      		cpse r25,__zero_reg__
 365 00ea 00C0      		rjmp .L22
 329:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_0, usbDescriptorString0)
 366               		.stabn	68,0,329,.LM40-.LFBB2
 367               	.LM40:
 368 00ec 80E0      		ldi r24,lo8(usbDescriptorString0)
 369 00ee 90E0      		ldi r25,hi8(usbDescriptorString0)
 370 00f0 9093 0000 		sts usbMsgPtr+1,r25
 371 00f4 8093 0000 		sts usbMsgPtr,r24
 372 00f8 84E0      		ldi r24,lo8(4)
 373 00fa 00C0      		rjmp .L20
 374               	.L22:
 332:usbdrv/usbdrv.c ****         SWITCH_CASE(2)
 375               		.stabn	68,0,332,.LM41-.LFBB2
 376               	.LM41:
 377 00fc 9230      		cpi r25,lo8(2)
 378 00fe 01F4      		brne .L49
 333:usbdrv/usbdrv.c ****             GET_DESCRIPTOR(USB_CFG_DESCR_PROPS_STRING_PRODUCT, usbDescriptorStringDevice)
 379               		.stabn	68,0,333,.LM42-.LFBB2
 380               	.LM42:
 381 0100 80E0      		ldi r24,lo8(usbDescriptorStringDevice)
 382 0102 90E0      		ldi r25,hi8(usbDescriptorStringDevice)
 383 0104 9093 0000 		sts usbMsgPtr+1,r25
 384 0108 8093 0000 		sts usbMsgPtr,r24
 385 010c 86E1      		ldi r24,lo8(22)
 386 010e 00C0      		rjmp .L20
 387               	.L49:
 388               	.LBE61:
 389               	.LBE60:
 313:usbdrv/usbdrv.c **** usbMsgLen_t len = 0;
 390               		.stabn	68,0,313,.LM43-.LFBB2
 391               	.LM43:
 392 0110 80E0      		ldi r24,0
 393               	.L20:
 353:usbdrv/usbdrv.c ****     usbMsgFlags = flags;
 394               		.stabn	68,0,353,.LM44-.LFBB2
 395               	.LM44:
 396 0112 90E4      		ldi r25,lo8(64)
 397 0114 9093 0000 		sts usbMsgFlags,r25
 398 0118 00C0      		rjmp .L14
 399               	.L18:
 400               	.LBE59:
 401               	.LBE58:
 395:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_CONFIGURATION)    /* 8 */
 402               		.stabn	68,0,395,.LM45-.LFBB2
 403               	.LM45:
 404 011a 8830      		cpi r24,lo8(8)
 405 011c 01F0      		breq .L50
 398:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_CONFIGURATION)    /* 9 */
 406               		.stabn	68,0,398,.LM46-.LFBB2
 407               	.LM46:
GAS LISTING /tmp/ccBGRCFe.s 			page 19


 408 011e 8930      		cpi r24,lo8(9)
 409 0120 01F4      		brne .L24
 399:usbdrv/usbdrv.c ****         usbConfiguration = value;
 410               		.stabn	68,0,399,.LM47-.LFBB2
 411               	.LM47:
 412 0122 9093 0000 		sts usbConfiguration,r25
 413 0126 00C0      		rjmp .L52
 414               	.L24:
 401:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_GET_INTERFACE)        /* 10 */
 415               		.stabn	68,0,401,.LM48-.LFBB2
 416               	.LM48:
 417 0128 8A30      		cpi r24,lo8(10)
 418 012a 01F0      		breq .L51
 404:usbdrv/usbdrv.c ****     SWITCH_CASE(USBRQ_SET_INTERFACE)        /* 11 */
 419               		.stabn	68,0,404,.LM49-.LFBB2
 420               	.LM49:
 421 012c 8B30      		cpi r24,lo8(11)
 422 012e 01F4      		brne .L52
 423               	.LBB62:
 424               	.LBB63:
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 425               		.stabn	68,0,200,.LM50-.LFBB2
 426               	.LM50:
 427 0130 8BE4      		ldi r24,lo8(75)
 428 0132 8093 0000 		sts usbTxStatus1+1,r24
 429 0136 00C0      		rjmp .L52
 430               	.L50:
 431               	.LBE63:
 432               	.LBE62:
 396:usbdrv/usbdrv.c ****         dataPtr = &usbConfiguration;  /* send current configuration value */
 433               		.stabn	68,0,396,.LM51-.LFBB2
 434               	.LM51:
 435 0138 20E0      		ldi r18,lo8(usbConfiguration)
 436 013a 30E0      		ldi r19,hi8(usbConfiguration)
 437 013c 00C0      		rjmp .L72
 438               	.L51:
 439               	.LBE65:
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 440               		.stabn	68,0,364,.LM52-.LFBB2
 441               	.LM52:
 442 013e 20E0      		ldi r18,lo8(usbTxBuf+9)
 443 0140 30E0      		ldi r19,hi8(usbTxBuf+9)
 444               	.L72:
 445               	.LBB66:
 402:usbdrv/usbdrv.c ****         len = 1;
 446               		.stabn	68,0,402,.LM53-.LFBB2
 447               	.LM53:
 448 0142 81E0      		ldi r24,lo8(1)
 449 0144 00C0      		rjmp .L16
 450               	.L52:
 451               	.LBE66:
 364:usbdrv/usbdrv.c **** uchar   len  = 0, *dataPtr = usbTxBuf + 9;  /* there are 2 bytes free space at the end of the buffe
 452               		.stabn	68,0,364,.LM54-.LFBB2
 453               	.LM54:
 454 0146 20E0      		ldi r18,lo8(usbTxBuf+9)
 455 0148 30E0      		ldi r19,hi8(usbTxBuf+9)
 456 014a 80E0      		ldi r24,0
GAS LISTING /tmp/ccBGRCFe.s 			page 20


 457               	.L16:
 411:usbdrv/usbdrv.c ****     usbMsgPtr = dataPtr;
 458               		.stabn	68,0,411,.LM55-.LFBB2
 459               	.LM55:
 460 014c 3093 0000 		sts usbMsgPtr+1,r19
 461 0150 2093 0000 		sts usbMsgPtr,r18
 462               	.L23:
 463 0154 00C0      		rjmp .L14
 464               	.L13:
 465               	.LBE67:
 466               	.LBE68:
 456:usbdrv/usbdrv.c ****             if((rq->bmRequestType & USBRQ_DIR_MASK) != USBRQ_DIR_HOST_TO_DEVICE){
 467               		.stabn	68,0,456,.LM56-.LFBB2
 468               	.LM56:
 469 0156 9881      		ld r25,Y
 470 0158 97FD      		sbrc r25,7
 458:usbdrv/usbdrv.c ****                     replyLen = rq->wLength.bytes[0];
 471               		.stabn	68,0,458,.LM57-.LFBB2
 472               	.LM57:
 473 015a 8E81      		ldd r24,Y+6
 474               	.L25:
 463:usbdrv/usbdrv.c ****             usbMsgFlags = USB_FLG_USE_USER_RW;
 475               		.stabn	68,0,463,.LM58-.LFBB2
 476               	.LM58:
 477 015c 90E8      		ldi r25,lo8(-128)
 478 015e 9093 0000 		sts usbMsgFlags,r25
 479 0162 00C0      		rjmp .L26
 480               	.L14:
 467:usbdrv/usbdrv.c ****             if(!rq->wLength.bytes[1] && replyLen > rq->wLength.bytes[0])    /* limit length to max 
 481               		.stabn	68,0,467,.LM59-.LFBB2
 482               	.LM59:
 483 0164 9F81      		ldd r25,Y+7
 484 0166 9111      		cpse r25,__zero_reg__
 485 0168 00C0      		rjmp .L26
 486 016a 9E81      		ldd r25,Y+6
 487 016c 9817      		cp r25,r24
 488 016e 00F4      		brsh .L26
 489 0170 892F      		mov r24,r25
 490               	.L26:
 473:usbdrv/usbdrv.c ****         usbMsgLen = replyLen;
 491               		.stabn	68,0,473,.LM60-.LFBB2
 492               	.LM60:
 493 0172 8093 0000 		sts usbMsgLen,r24
 494 0176 00C0      		rjmp .L11
 495               	.L9:
 496               	.LBE69:
 476:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 497               		.stabn	68,0,476,.LM61-.LFBB2
 498               	.LM61:
 499 0178 8091 0000 		lds r24,usbMsgFlags
 500 017c 87FF      		sbrs r24,7
 501 017e 00C0      		rjmp .L11
 502               	.LBB70:
 477:usbdrv/usbdrv.c ****             uchar rval = usbFunctionWrite(data, len);
 503               		.stabn	68,0,477,.LM62-.LFBB2
 504               	.LM62:
 505 0180 CE01      		movw r24,r28
GAS LISTING /tmp/ccBGRCFe.s 			page 21


 506 0182 00D0      		rcall usbFunctionWrite
 478:usbdrv/usbdrv.c ****             if(rval == 0xff){   /* an error occurred */
 507               		.stabn	68,0,478,.LM63-.LFBB2
 508               	.LM63:
 509 0184 8F3F      		cpi r24,lo8(-1)
 510 0186 01F4      		brne .L29
 479:usbdrv/usbdrv.c ****                 usbTxLen = USBPID_STALL;
 511               		.stabn	68,0,479,.LM64-.LFBB2
 512               	.LM64:
 513 0188 8EE1      		ldi r24,lo8(30)
 514 018a 8093 0000 		sts usbTxLen,r24
 515 018e 00C0      		rjmp .L11
 516               	.L29:
 480:usbdrv/usbdrv.c ****             }else if(rval != 0){    /* This was the final package */
 517               		.stabn	68,0,480,.LM65-.LFBB2
 518               	.LM65:
 519 0190 8111      		cpse r24,__zero_reg__
 481:usbdrv/usbdrv.c ****                 usbMsgLen = 0;  /* answer with a zero-sized data packet */
 520               		.stabn	68,0,481,.LM66-.LFBB2
 521               	.LM66:
 522 0192 1092 0000 		sts usbMsgLen,__zero_reg__
 523               	.L11:
 524               	.LBE70:
 525               	.LBE71:
 526               	.LBE72:
 580:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_FLOWCONTROL
 581:usbdrv/usbdrv.c ****         if(usbRxLen > 0)    /* only mark as available if not inactivated */
 582:usbdrv/usbdrv.c ****             usbRxLen = 0;
 583:usbdrv/usbdrv.c **** #else
 584:usbdrv/usbdrv.c ****         usbRxLen = 0;       /* mark rx buffer as available */
 527               		.stabn	68,0,584,.LM67-.LFBB2
 528               	.LM67:
 529 0196 1092 0000 		sts usbRxLen,__zero_reg__
 530               	.L8:
 585:usbdrv/usbdrv.c **** #endif
 586:usbdrv/usbdrv.c ****     }
 587:usbdrv/usbdrv.c ****     if(usbTxLen & 0x10){    /* transmit system idle */
 531               		.stabn	68,0,587,.LM68-.LFBB2
 532               	.LM68:
 533 019a 8091 0000 		lds r24,usbTxLen
 534 019e 84FF      		sbrs r24,4
 535 01a0 00C0      		rjmp .L30
 588:usbdrv/usbdrv.c ****         if(usbMsgLen != USB_NO_MSG){    /* transmit data pending? */
 536               		.stabn	68,0,588,.LM69-.LFBB2
 537               	.LM69:
 538 01a2 8091 0000 		lds r24,usbMsgLen
 539 01a6 8F3F      		cpi r24,lo8(-1)
 540 01a8 01F4      		brne .+2
 541 01aa 00C0      		rjmp .L30
 542 01ac C82F      		mov r28,r24
 543 01ae 8930      		cpi r24,lo8(9)
 544 01b0 00F0      		brlo .L31
 545 01b2 C8E0      		ldi r28,lo8(8)
 546               	.L31:
 547               	.LBB73:
 548               	.LBB74:
 533:usbdrv/usbdrv.c ****     usbMsgLen -= wantLen;
GAS LISTING /tmp/ccBGRCFe.s 			page 22


 549               		.stabn	68,0,533,.LM70-.LFBB2
 550               	.LM70:
 551 01b4 8C1B      		sub r24,r28
 552 01b6 8093 0000 		sts usbMsgLen,r24
 534:usbdrv/usbdrv.c ****     usbTxBuf[0] ^= USBPID_DATA0 ^ USBPID_DATA1; /* DATA toggling */
 553               		.stabn	68,0,534,.LM71-.LFBB2
 554               	.LM71:
 555 01ba 8091 0000 		lds r24,usbTxBuf
 556 01be 98E8      		ldi r25,lo8(-120)
 557 01c0 8927      		eor r24,r25
 558 01c2 8093 0000 		sts usbTxBuf,r24
 559               	.LBB75:
 560               	.LBB76:
 495:usbdrv/usbdrv.c ****     if(len > 0){    /* don't bother app with 0 sized reads */
 561               		.stabn	68,0,495,.LM72-.LFBB2
 562               	.LM72:
 563 01c6 CC23      		tst r28
 564 01c8 01F0      		breq .L32
 497:usbdrv/usbdrv.c ****         if(usbMsgFlags & USB_FLG_USE_USER_RW){
 565               		.stabn	68,0,497,.LM73-.LFBB2
 566               	.LM73:
 567 01ca 8091 0000 		lds r24,usbMsgFlags
 568 01ce 87FF      		sbrs r24,7
 569 01d0 00C0      		rjmp .L33
 498:usbdrv/usbdrv.c ****             len = usbFunctionRead(data, len);
 570               		.stabn	68,0,498,.LM74-.LFBB2
 571               	.LM74:
 572 01d2 6C2F      		mov r22,r28
 573 01d4 80E0      		ldi r24,lo8(usbTxBuf+1)
 574 01d6 90E0      		ldi r25,hi8(usbTxBuf+1)
 575 01d8 00D0      		rcall usbFunctionRead
 576 01da C82F      		mov r28,r24
 577               	.LBE76:
 578               	.LBE75:
 536:usbdrv/usbdrv.c ****     if(len <= 8){           /* valid data packet */
 579               		.stabn	68,0,536,.LM75-.LFBB2
 580               	.LM75:
 581 01dc 8930      		cpi r24,lo8(9)
 582 01de 00F4      		brsh .L71
 583 01e0 00C0      		rjmp .L32
 584               	.L33:
 585               	.LBB81:
 586               	.LBB80:
 587               	.LBB77:
 502:usbdrv/usbdrv.c ****             uchar i = len, *r = usbMsgPtr;
 588               		.stabn	68,0,502,.LM76-.LFBB2
 589               	.LM76:
 590 01e2 4091 0000 		lds r20,usbMsgPtr
 591 01e6 5091 0000 		lds r21,usbMsgPtr+1
 503:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 592               		.stabn	68,0,503,.LM77-.LFBB2
 593               	.LM77:
 594 01ea 86FF      		sbrs r24,6
 595 01ec 00C0      		rjmp .L35
 596 01ee A0E0      		ldi r26,lo8(usbTxBuf+1)
 597 01f0 B0E0      		ldi r27,hi8(usbTxBuf+1)
 598 01f2 FA01      		movw r30,r20
GAS LISTING /tmp/ccBGRCFe.s 			page 23


 599 01f4 8C2F      		mov r24,r28
 600 01f6 8A0F      		add r24,r26
 601               	.L38:
 602               	.LBB78:
 603               	.LBB79:
 505:usbdrv/usbdrv.c ****                     uchar c = USB_READ_FLASH(r);    /* assign to char size variable to enforce byte
 604               		.stabn	68,0,505,.LM78-.LFBB2
 605               	.LM78:
 606               	/* #APP */
 607               	 ;  505 "usbdrv/usbdrv.c" 1
 608 01f8 9491      		lpm r25, Z
 609               		
 610               	 ;  0 "" 2
 611               	/* #NOAPP */
 612               	.LBE79:
 506:usbdrv/usbdrv.c ****                     *data++ = c;
 613               		.stabn	68,0,506,.LM79-.LFBB2
 614               	.LM79:
 615 01fa 9D93      		st X+,r25
 507:usbdrv/usbdrv.c ****                     r++;
 616               		.stabn	68,0,507,.LM80-.LFBB2
 617               	.LM80:
 618 01fc 3196      		adiw r30,1
 619               	.LBE78:
 508:usbdrv/usbdrv.c ****                 }while(--i);
 620               		.stabn	68,0,508,.LM81-.LFBB2
 621               	.LM81:
 622 01fe 8A13      		cpse r24,r26
 623 0200 00C0      		rjmp .L38
 624 0202 00C0      		rjmp .L73
 625               	.L35:
 626 0204 DA01      		movw r26,r20
 503:usbdrv/usbdrv.c ****             if(usbMsgFlags & USB_FLG_MSGPTR_IS_ROM){    /* ROM data */
 627               		.stabn	68,0,503,.LM82-.LFBB2
 628               	.LM82:
 629 0206 E0E0      		ldi r30,lo8(usbTxBuf+1)
 630 0208 F0E0      		ldi r31,hi8(usbTxBuf+1)
 631 020a 8C2F      		mov r24,r28
 632 020c 8E0F      		add r24,r30
 633               	.L40:
 511:usbdrv/usbdrv.c ****                     *data++ = *r++;
 634               		.stabn	68,0,511,.LM83-.LFBB2
 635               	.LM83:
 636 020e 9D91      		ld r25,X+
 637 0210 9193      		st Z+,r25
 512:usbdrv/usbdrv.c ****                 }while(--i);
 638               		.stabn	68,0,512,.LM84-.LFBB2
 639               	.LM84:
 640 0212 8E13      		cpse r24,r30
 641 0214 00C0      		rjmp .L40
 642               	.L73:
 643 0216 2FEF      		ldi r18,lo8(-1)
 644 0218 2C0F      		add r18,r28
 645 021a 30E0      		ldi r19,0
 646 021c 2F5F      		subi r18,-1
 647 021e 3F4F      		sbci r19,-1
 648 0220 240F      		add r18,r20
GAS LISTING /tmp/ccBGRCFe.s 			page 24


 649 0222 351F      		adc r19,r21
 514:usbdrv/usbdrv.c ****             usbMsgPtr = r;
 650               		.stabn	68,0,514,.LM85-.LFBB2
 651               	.LM85:
 652 0224 3093 0000 		sts usbMsgPtr+1,r19
 653 0228 2093 0000 		sts usbMsgPtr,r18
 654               	.L32:
 655               	.LBE77:
 656               	.LBE80:
 657               	.LBE81:
 537:usbdrv/usbdrv.c ****         usbCrc16Append(&usbTxBuf[1], len);
 658               		.stabn	68,0,537,.LM86-.LFBB2
 659               	.LM86:
 660 022c 6C2F      		mov r22,r28
 661 022e 80E0      		ldi r24,lo8(usbTxBuf+1)
 662 0230 90E0      		ldi r25,hi8(usbTxBuf+1)
 663 0232 00D0      		rcall usbCrc16Append
 538:usbdrv/usbdrv.c ****         len += 4;           /* length including sync byte */
 664               		.stabn	68,0,538,.LM87-.LFBB2
 665               	.LM87:
 666 0234 CC5F      		subi r28,lo8(-(4))
 539:usbdrv/usbdrv.c ****         if(len < 12)        /* a partial package identifies end of message */
 667               		.stabn	68,0,539,.LM88-.LFBB2
 668               	.LM88:
 669 0236 CC30      		cpi r28,lo8(12)
 670 0238 01F0      		breq .L41
 540:usbdrv/usbdrv.c ****             usbMsgLen = USB_NO_MSG;
 671               		.stabn	68,0,540,.LM89-.LFBB2
 672               	.LM89:
 673 023a 8FEF      		ldi r24,lo8(-1)
 674 023c 8093 0000 		sts usbMsgLen,r24
 675 0240 00C0      		rjmp .L41
 676               	.L71:
 543:usbdrv/usbdrv.c ****         usbMsgLen = USB_NO_MSG;
 677               		.stabn	68,0,543,.LM90-.LFBB2
 678               	.LM90:
 679 0242 8FEF      		ldi r24,lo8(-1)
 680 0244 8093 0000 		sts usbMsgLen,r24
 542:usbdrv/usbdrv.c ****         len = USBPID_STALL;   /* stall the endpoint */
 681               		.stabn	68,0,542,.LM91-.LFBB2
 682               	.LM91:
 683 0248 CEE1      		ldi r28,lo8(30)
 684               	.L41:
 545:usbdrv/usbdrv.c ****     usbTxLen = len;
 685               		.stabn	68,0,545,.LM92-.LFBB2
 686               	.LM92:
 687 024a C093 0000 		sts usbTxLen,r28
 688               	.L30:
 689               	.LBE74:
 690               	.LBE73:
 589:usbdrv/usbdrv.c ****             usbBuildTxBlock();
 590:usbdrv/usbdrv.c ****         }
 591:usbdrv/usbdrv.c ****     }
 592:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 691               		.stabn	68,0,592,.LM93-.LFBB2
 692               	.LM93:
 693 024e 84E1      		ldi r24,lo8(20)
GAS LISTING /tmp/ccBGRCFe.s 			page 25


 694               	.L44:
 695               	.LBB82:
 593:usbdrv/usbdrv.c ****         uchar usbLineStatus = USBIN & USBMASK;
 696               		.stabn	68,0,593,.LM94-.LFBB2
 697               	.LM94:
 698 0250 96B3      		in r25,0x16
 699 0252 9871      		andi r25,lo8(24)
 594:usbdrv/usbdrv.c ****         if(usbLineStatus != 0)  /* SE0 has ended */
 700               		.stabn	68,0,594,.LM95-.LFBB2
 701               	.LM95:
 702 0254 01F4      		brne .L42
 703               	.LBE82:
 592:usbdrv/usbdrv.c ****     for(i = 20; i > 0; i--){
 704               		.stabn	68,0,592,.LM96-.LFBB2
 705               	.LM96:
 706 0256 8150      		subi r24,lo8(-(-1))
 707 0258 01F4      		brne .L44
 595:usbdrv/usbdrv.c ****             goto isNotReset;
 596:usbdrv/usbdrv.c ****     }
 597:usbdrv/usbdrv.c ****     /* RESET condition, called multiple times during reset */
 598:usbdrv/usbdrv.c ****     usbNewDeviceAddr = 0;
 708               		.stabn	68,0,598,.LM97-.LFBB2
 709               	.LM97:
 710 025a 1092 0000 		sts usbNewDeviceAddr,__zero_reg__
 599:usbdrv/usbdrv.c ****     usbDeviceAddr = 0;
 711               		.stabn	68,0,599,.LM98-.LFBB2
 712               	.LM98:
 713 025e 1092 0000 		sts usbDeviceAddr,__zero_reg__
 714               	.L42:
 715               	.LBB83:
 716               	.LBB84:
 555:usbdrv/usbdrv.c **** uchar           isReset = !notResetState;
 717               		.stabn	68,0,555,.LM99-.LFBB2
 718               	.LM99:
 719 0262 C1E0      		ldi r28,lo8(1)
 720 0264 8111      		cpse r24,__zero_reg__
 721 0266 C0E0      		ldi r28,0
 722               	.L45:
 557:usbdrv/usbdrv.c ****     if(wasReset != isReset){
 723               		.stabn	68,0,557,.LM100-.LFBB2
 724               	.LM100:
 725 0268 8091 0000 		lds r24,wasReset.1791
 726 026c 8C17      		cp r24,r28
 727 026e 01F0      		breq .L7
 558:usbdrv/usbdrv.c ****         USB_RESET_HOOK(isReset);
 728               		.stabn	68,0,558,.LM101-.LFBB2
 729               	.LM101:
 730 0270 C111      		cpse r28,__zero_reg__
 731 0272 00C0      		rjmp .L47
 732 0274 00D0      		rcall usbEventResetReady
 733               	.L47:
 559:usbdrv/usbdrv.c ****         wasReset = isReset;
 734               		.stabn	68,0,559,.LM102-.LFBB2
 735               	.LM102:
 736 0276 C093 0000 		sts wasReset.1791,r28
 737               	.L7:
 738               	/* epilogue start */
GAS LISTING /tmp/ccBGRCFe.s 			page 26


 739               	.LBE84:
 740               	.LBE83:
 600:usbdrv/usbdrv.c ****     usbResetStall();
 601:usbdrv/usbdrv.c ****     DBG1(0xff, 0, 0);
 602:usbdrv/usbdrv.c **** isNotReset:
 603:usbdrv/usbdrv.c ****     usbHandleResetHook(i);
 604:usbdrv/usbdrv.c **** }
 741               		.stabn	68,0,604,.LM103-.LFBB2
 742               	.LM103:
 743 027a DF91      		pop r29
 744 027c CF91      		pop r28
 745 027e 0895      		ret
 746               		.size	usbPoll, .-usbPoll
 747               		.stabs	"i:r(0,11)",64,0,569,24
 748               		.stabn	192,0,0,.LFBB2-.LFBB2
 749               		.stabs	"dataPtr:r(0,48)=*(0,11)",64,0,364,18
 750               		.stabs	"value:r(0,11)",64,0,365,25
 751               		.stabn	192,0,0,.LBB54-.LFBB2
 752               		.stabs	"_cmd:r(0,11)",64,0,371,24
 753               		.stabn	192,0,0,.LBB55-.LFBB2
 754               		.stabs	"_cmd:r(0,11)",64,0,316,24
 755               		.stabn	192,0,0,.LBB60-.LFBB2
 756               		.stabn	224,0,0,.LBE60-.LFBB2
 757               		.stabn	224,0,0,.LBE55-.LFBB2
 758               		.stabs	"_cmd:r(0,11)",64,0,371,24
 759               		.stabn	192,0,0,.LBB64-.LFBB2
 760               		.stabn	224,0,0,.LBE64-.LFBB2
 761               		.stabs	"_cmd:r(0,11)",64,0,371,24
 762               		.stabn	192,0,0,.LBB65-.LFBB2
 763               		.stabn	224,0,0,.LBE65-.LFBB2
 764               		.stabs	"_cmd:r(0,11)",64,0,371,24
 765               		.stabn	192,0,0,.LBB66-.LFBB2
 766               		.stabn	224,0,0,.LBE66-.LFBB2
 767               		.stabn	224,0,0,.LBE54-.LFBB2
 768               		.stabs	"dataPtr:r(0,48)",64,0,364,18
 769               		.stabs	"value:r(0,11)",64,0,365,25
 770               		.stabn	192,0,0,.LBB67-.LFBB2
 771               		.stabn	224,0,0,.LBE67-.LFBB2
 772               		.stabs	"rval:r(0,11)",64,0,477,24
 773               		.stabn	192,0,0,.LBB70-.LFBB2
 774               		.stabn	224,0,0,.LBE70-.LFBB2
 775               		.stabs	"isReset:r(0,11)",64,0,555,28
 776               		.stabn	192,0,0,.LBB84-.LFBB2
 777               		.stabn	224,0,0,.LBE84-.LFBB2
 778               		.stabn	224,0,0,.Lscope2-.LFBB2
 779               	.Lscope2:
 780               		.stabs	"",36,0,0,.Lscope2-.LFBB2
 781               		.stabd	78,0,0
 782               		.stabs	"usbInit:F(0,47)",36,0,608,usbInit
 783               	.global	usbInit
 784               		.type	usbInit, @function
 785               	usbInit:
 786               		.stabd	46,0,0
 605:usbdrv/usbdrv.c **** 
 606:usbdrv/usbdrv.c **** /* ------------------------------------------------------------------------- */
 607:usbdrv/usbdrv.c **** 
 608:usbdrv/usbdrv.c **** USB_PUBLIC void usbInit(void)
GAS LISTING /tmp/ccBGRCFe.s 			page 27


 609:usbdrv/usbdrv.c **** {
 787               		.stabn	68,0,609,.LM104-.LFBB3
 788               	.LM104:
 789               	.LFBB3:
 790               	/* prologue: function */
 791               	/* frame size = 0 */
 792               	/* stack size = 0 */
 793               	.L__stack_usage = 0
 610:usbdrv/usbdrv.c **** #if USB_INTR_CFG_SET != 0
 611:usbdrv/usbdrv.c ****     USB_INTR_CFG |= USB_INTR_CFG_SET;
 794               		.stabn	68,0,611,.LM105-.LFBB3
 795               	.LM105:
 796 0280 AB9A      		sbi 0x15,3
 612:usbdrv/usbdrv.c **** #endif
 613:usbdrv/usbdrv.c **** #if USB_INTR_CFG_CLR != 0
 614:usbdrv/usbdrv.c ****     USB_INTR_CFG &= ~(USB_INTR_CFG_CLR);
 615:usbdrv/usbdrv.c **** #endif
 616:usbdrv/usbdrv.c ****     USB_INTR_ENABLE |= (1 << USB_INTR_ENABLE_BIT);
 797               		.stabn	68,0,616,.LM106-.LFBB3
 798               	.LM106:
 799 0282 8BB7      		in r24,0x3b
 800 0284 8062      		ori r24,lo8(32)
 801 0286 8BBF      		out 0x3b,r24
 802               	.LBB85:
 803               	.LBB86:
 200:usbdrv/usbdrv.c ****     USB_SET_DATATOKEN1(USB_INITIAL_DATATOKEN);  /* reset data toggling for interrupt endpoint */
 804               		.stabn	68,0,200,.LM107-.LFBB3
 805               	.LM107:
 806 0288 8BE4      		ldi r24,lo8(75)
 807 028a 8093 0000 		sts usbTxStatus1+1,r24
 808               	.LBE86:
 809               	.LBE85:
 617:usbdrv/usbdrv.c ****     usbResetDataToggling();
 618:usbdrv/usbdrv.c **** #if USB_CFG_HAVE_INTRIN_ENDPOINT && !USB_CFG_SUPPRESS_INTR_CODE
 619:usbdrv/usbdrv.c ****     usbTxLen1 = USBPID_NAK;
 810               		.stabn	68,0,619,.LM108-.LFBB3
 811               	.LM108:
 812 028e 8AE5      		ldi r24,lo8(90)
 813 0290 8093 0000 		sts usbTxStatus1,r24
 814 0294 0895      		ret
 815               		.size	usbInit, .-usbInit
 816               	.Lscope3:
 817               		.stabs	"",36,0,0,.Lscope3-.LFBB3
 818               		.stabd	78,0,0
 819               		.local	wasReset.1791
 820               		.comm	wasReset.1791,1,1
 821               	.global	usbDescriptorConfiguration
 822               		.section	.progmem.data,"a",@progbits
 823               		.type	usbDescriptorConfiguration, @object
 824               		.size	usbDescriptorConfiguration, 25
 825               	usbDescriptorConfiguration:
 826 0000 09        		.byte	9
 827 0001 02        		.byte	2
 828 0002 19        		.byte	25
 829 0003 00        		.byte	0
 830 0004 01        		.byte	1
 831 0005 01        		.byte	1
GAS LISTING /tmp/ccBGRCFe.s 			page 28


 832 0006 00        		.byte	0
 833 0007 80        		.byte	-128
 834 0008 64        		.byte	100
 835 0009 09        		.byte	9
 836 000a 04        		.byte	4
 837 000b 00        		.byte	0
 838 000c 00        		.byte	0
 839 000d 01        		.byte	1
 840 000e FF        		.byte	-1
 841 000f 00        		.byte	0
 842 0010 00        		.byte	0
 843 0011 00        		.byte	0
 844 0012 07        		.byte	7
 845 0013 05        		.byte	5
 846 0014 81        		.byte	-127
 847 0015 03        		.byte	3
 848 0016 08        		.byte	8
 849 0017 00        		.byte	0
 850 0018 0A        		.byte	10
 851               	.global	usbDescriptorDevice
 852               		.type	usbDescriptorDevice, @object
 853               		.size	usbDescriptorDevice, 18
 854               	usbDescriptorDevice:
 855 0019 12        		.byte	18
 856 001a 01        		.byte	1
 857 001b 10        		.byte	16
 858 001c 01        		.byte	1
 859 001d 00        		.byte	0
 860 001e 00        		.byte	0
 861 001f 00        		.byte	0
 862 0020 08        		.byte	8
 863 0021 81        		.byte	-127
 864 0022 17        		.byte	23
 865 0023 9F        		.byte	-97
 866 0024 0C        		.byte	12
 867 0025 04        		.byte	4
 868 0026 01        		.byte	1
 869 0027 00        		.byte	0
 870 0028 02        		.byte	2
 871 0029 00        		.byte	0
 872 002a 01        		.byte	1
 873               	.global	usbDescriptorStringDevice
 874               		.type	usbDescriptorStringDevice, @object
 875               		.size	usbDescriptorStringDevice, 22
 876               	usbDescriptorStringDevice:
 877 002b 1603      		.word	790
 878 002d 5500      		.word	85
 879 002f 5300      		.word	83
 880 0031 4200      		.word	66
 881 0033 7400      		.word	116
 882 0035 6900      		.word	105
 883 0037 6E00      		.word	110
 884 0039 7900      		.word	121
 885 003b 5300      		.word	83
 886 003d 5000      		.word	80
 887 003f 4900      		.word	73
 888               	.global	usbDescriptorString0
GAS LISTING /tmp/ccBGRCFe.s 			page 29


 889               		.type	usbDescriptorString0, @object
 890               		.size	usbDescriptorString0, 4
 891               	usbDescriptorString0:
 892 0041 04        		.byte	4
 893 0042 03        		.byte	3
 894 0043 09        		.byte	9
 895 0044 04        		.byte	4
 896               		.local	usbMsgFlags
 897               		.comm	usbMsgFlags,1,1
 898               		.data
 899               		.type	usbMsgLen, @object
 900               		.size	usbMsgLen, 1
 901               	usbMsgLen:
 902 0000 FF        		.byte	-1
 903               		.comm	usbMsgPtr,2,1
 904               		.comm	usbTxStatus1,12,1
 905               		.comm	usbTxBuf,11,1
 906               	.global	usbTxLen
 907               		.type	usbTxLen, @object
 908               		.size	usbTxLen, 1
 909               	usbTxLen:
 910 0001 5A        		.byte	90
 911               		.comm	usbRxToken,1,1
 912               		.comm	usbCurrentTok,1,1
 913               		.comm	usbRxLen,1,1
 914               		.comm	usbConfiguration,1,1
 915               		.comm	usbNewDeviceAddr,1,1
 916               		.comm	usbDeviceAddr,1,1
 917               		.comm	usbInputBufOffset,1,1
 918               		.comm	usbRxBuf,22,1
 919               		.stabs	"usbMsgLen:S(0,11)",38,0,49,usbMsgLen
 920               		.stabs	"usbMsgFlags:S(0,11)",40,0,50,usbMsgFlags
 921               		.stabs	"usbMsgPtr:G(0,48)",32,0,48,0
 922               		.stabs	"usbRxToken:G(0,11)",32,0,31,0
 923               		.stabs	"usbConfiguration:G(0,11)",32,0,28,0
 924               		.stabs	"usbDescriptorDevice:G(0,49)=ar(10,4);0;17;(0,50)=k(0,2)",32,0,111,0
 925               		.stabs	"usbDescriptorConfiguration:G(0,51)=ar(10,4);0;24;(0,50)",32,0,142,0
 926               		.stabs	"usbDescriptorString0:G(0,52)=ar(10,4);0;3;(0,50)",32,0,70,0
 927               		.stabs	"usbDescriptorStringDevice:G(0,53)=ar(10,4);0;10;(0,54)=k(0,1)",32,0,89,0
 928               		.stabs	"usbTxStatus1:G(10,5)",32,0,38,0
 929               		.stabs	"usbRxBuf:G(0,55)=ar(10,4);0;21;(0,11)",32,0,24,0
 930               		.stabs	"usbInputBufOffset:G(0,11)",32,0,25,0
 931               		.stabs	"usbDeviceAddr:G(0,11)",32,0,26,0
 932               		.stabs	"usbNewDeviceAddr:G(0,11)",32,0,27,0
 933               		.stabs	"usbRxLen:G(0,56)=B(0,10)",32,0,29,0
 934               		.stabs	"usbCurrentTok:G(0,11)",32,0,30,0
 935               		.stabs	"usbTxLen:G(10,2)",32,0,32,0
 936               		.stabs	"usbTxBuf:G(10,3)",32,0,33,0
 937               		.text
 938               		.stabs	"",100,0,0,.Letext0
 939               	.Letext0:
 940               		.ident	"GCC: (GNU) 4.8.0"
 941               	.global __do_copy_data
 942               	.global __do_clear_bss
GAS LISTING /tmp/ccBGRCFe.s 			page 30


DEFINED SYMBOLS
                            *ABS*:0000000000000000 usbdrv.c
     /tmp/ccBGRCFe.s:2      *ABS*:000000000000003d __SP_L__
     /tmp/ccBGRCFe.s:3      *ABS*:000000000000003f __SREG__
     /tmp/ccBGRCFe.s:4      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccBGRCFe.s:5      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccBGRCFe.s:120    .text:0000000000000000 usbSetInterrupt
                            *COM*:000000000000000c usbTxStatus1
     /tmp/ccBGRCFe.s:195    .text:0000000000000044 usbPoll
                            *COM*:0000000000000001 usbRxLen
                            *COM*:0000000000000001 usbInputBufOffset
                            *COM*:0000000000000016 usbRxBuf
                            *COM*:0000000000000001 usbRxToken
                            *COM*:000000000000000b usbTxBuf
     /tmp/ccBGRCFe.s:909    .data:0000000000000001 usbTxLen
     /tmp/ccBGRCFe.s:820    .bss:0000000000000001 usbMsgFlags
                            *COM*:0000000000000001 usbNewDeviceAddr
     /tmp/ccBGRCFe.s:854    .progmem.data:0000000000000019 usbDescriptorDevice
                            *COM*:0000000000000002 usbMsgPtr
     /tmp/ccBGRCFe.s:825    .progmem.data:0000000000000000 usbDescriptorConfiguration
     /tmp/ccBGRCFe.s:891    .progmem.data:0000000000000041 usbDescriptorString0
     /tmp/ccBGRCFe.s:876    .progmem.data:000000000000002b usbDescriptorStringDevice
                            *COM*:0000000000000001 usbConfiguration
     /tmp/ccBGRCFe.s:901    .data:0000000000000000 usbMsgLen
                            *COM*:0000000000000001 usbDeviceAddr
                             .bss:0000000000000000 wasReset.1791
     /tmp/ccBGRCFe.s:785    .text:0000000000000280 usbInit
                            *COM*:0000000000000001 usbCurrentTok

UNDEFINED SYMBOLS
usbCrc16Append
usbFunctionSetup
usbFunctionWrite
usbFunctionRead
usbEventResetReady
__do_copy_data
__do_clear_bss
